<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对进程和线程的认识和简要总结]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%AF%B9%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景略 进程什么是进程1、进程是系统管理和分配资源的基本单位，是一个动态概念 2、每个进程都有自己的地址空间，进程地址空间的大小和处理器的位数有关，16位长处理机的进程空间大小为216，32位处理机的进程空间大小为232 3、进程至少有5种基本状态，分别是： 新生 运行 等待（阻塞） 就绪 结束 进程间的8种通信方式1、无名管道（pipe）：半双工的通信方式，数据单向流动。只能在具有亲缘关系进程间使用（通常指父子进程关系） 2、高级管道（popen）：把另一个程序当做一个新的进程在当前程序进程中启动，算是当前程序的子进程3、有名管道（named pipe）：允许无亲缘关系进程间通信 4、信号（sinal）：信号是一种比较复杂的通信方式，用于通知接收进程某个时间已经发生 5、信号量(semophore)：信号量是一个计数器，可以控制多个进程对共享资源的访问。常常作为一种死锁机制，防止某个进程正在访问共享资源时其他进程也访问该资源。主要作为进程间以及同一进程内不同线程之间的同步手段。 6、消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点 7、共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信 8、套接字（socket）：套接字也是一种进程间通信机制，区别于其他方式，它可用于不同机器间的进程通信。通信过程如下： 1）命名socket 2）绑定机器本地地址 3）监听 4）连接服务器 5）互相发送接受数据 6）断开连接 线程什么是线程1、线程是操作系统中能后进行运算调度的最小单位2、线程被包含在进程之中，是进程中的实际运作单位3、一条线程指的是进程中一个单一顺序的控制流4、一个进程可以并发多个线程，每条线程并行执行不同的任务5、同一进程中的多条线程会共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等6、但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）7、线程有四种基本状态，分别是： 产生（spawn） 中断（block） 非中断（unblock） 结束（finish） 不同平台的线程待补充 跨平台的线程待补充 参考资料https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8Bhttps://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8Bhttp://www.xitongzhijia.net/xtjc/20171024/109869.html]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对HTTP协议认识的简要总结]]></title>
    <url>%2F2017%2F11%2F27%2F%E5%AF%B9HTTP%E5%8D%8F%E8%AE%AE%E8%AE%A4%E8%AF%86%E7%9A%84%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景做性能测试，压接口的时候，经常用到http协议的相关知识，特在此做个简单总结 http协议基础http通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 消息结构客户端请求消息结构： 请求行(requst line) 请求头部(header) 空行 请求数据 服务端响应消息结构： 状态行 消息报头 空行 响应正文 HTTP请求方法 未完待续参考资料http://www.runoob.com/http/http-tutorial.html https://www.toutiao.com/a6491506976181191181/?tt_from=mobile_qq&amp;utm_campaign=client_share&amp;app=news_article&amp;utm_source=mobile_qq&amp;iid=18059487869&amp;utm_medium=toutiao_android]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web自动化测试]]></title>
    <url>%2F2017%2F11%2F25%2Fweb%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[背景之前试着搞过公司云报道产品的自动化测试，基本设计思路以及相关问题，见文章内容。 进行前需要了解的测试框架使用哪种测试框架要根据所测产品的类型来进行选择。 桌面程序的工具有：QTP、 AutoRunner等 web应用的工具有：QTP、AutoRunner、selenium、Robot Framework、watir等 如果待测产品是C/S架构，可选QTP(也叫UFT) 主流的工具 易用性好 学习资料丰富 如果待测产品是B/S架构，推荐selenium 对B/S应用支持很好 支持多语言开发(java、python、ruby、php、C#、JavaScript等) 学习内容丰富，增加测试工程师的技术竞争力 开发语言如果使用QTP，必须掌握VBS 如果使用Selenium，可选语言丰富 从语言易学性来讲，首选python和ruby 从语言应用广度来讲，首选java、C#和php等 从语言相关测试技术成度来讲：ruby、python和java 考虑整个技术团队主流用什么语言，然后选择相应的语言。 思路1、自动化测试环境准备，本次采用Selenium+Eclipse+Java，详细安装配置过程略。 2、在自动化测试框架基础上，编写通用方法，如： 1）登录、配置浏览器系列操作 2）页面元素准确性判断（可自己简单编写，亦可采用其他一些监控对比工具，如：基于diff的页面差异监控、基于DOM树的页面差异监控） 3）case测试结果输出等 3、利用自动化测试框架，编写测试case，模拟用户输入、点击等操作； 4、使用正则表达式对准备好的测试数据进行操作； 5、测试执行过程自动输出测试结果至测试结果文档 需要注意的问题： 1、自动化测试的覆盖率，主要通过对需求点详细拆分，丰富测试数据来解决 2、UI自动化测试执行过程易受执行环境影响 3、记得还有，暂时想不起来了 总结目前的很多Web自动化测试框架都是通过操作Web中的控件，来模拟用户输入点击等操作，实现Web自动化测试。其实这些工具的原理大同小异，都是通过调用浏览器COM接口和HTML DOM对浏览器和Web测试对象进行操作。 工具是死的，人是活的，怎么用，怎么丰富，都是需要自己亲自去尝试着做，才能真正了解。 参考资料:https://www.cnblogs.com/fnng/p/3653793.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Jenkins持续构建的初步了解]]></title>
    <url>%2F2017%2F11%2F25%2FJenkins%2F</url>
    <content type="text"><![CDATA[背景略 什么是Jenkins什么是JenkinsJenkins是一个用Java编写的开源的持续集成工具，提供了软件开发的持续集成服务，可监控并触发持续重复的工作，具有开源，支持多平台和插件扩展，安装简单，界面化管理等特点。更多介绍参考维基介绍. Jenkins有哪些功能Jenkins的主要功能包括： 1、持续的软件版本发布/测试项目。 2、监控外部调用执行的工作。 Jenkins的特点1、易于安装-只要把jenkins.war部署到servlet容器，不需要数据库支持。 2、易于配置-所有配置都是通过其提供的web界面实现。 3、集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知。 4、生成JUnit/TestNG测试报告。 5、分布式构建支持Jenkins能够让多台计算机一起构建/测试。 6、文件识别:Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。 7、插件支持:支持扩展插件，你可以开发适合自己团队使用的工具。 Jenkins能做什么1、软件构建自动化: 配置完成后，CI系统会依照预先制定的时间表，或者针对某一特定事件，对目标软件进行构建。 2、构建可持续的自动化检查: CI系统能持续地获取新增或修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时，CI系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力(说直接一点也是钱啊，呵呵)。 3、构建可持续的自动化测试: 构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知(Email,RSS等等)给相关的当事人。 4、生成后后续过程的自动化: 当自动化检查和测试成功完成，软件构建的周期中可能也需要一些额外的任务，诸如生成文档、打包软件、部署构件到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用。 Jenkins部署Jenkins官网有适应不同平台的不同安装方式，考虑到要做成稳定的服务，本次下载war Jenkins依赖于Java环境，首先需要安装和配置Java环境，详细步骤省略 直接启动java -jar jenkins.war 借助中间件或容器1、安装配置tomcat 2、配置nginx代理 3、部署Jenkins 4、启动 Jenkins部署新项目登录Jenkins访问上一步中配置好的域名 初次登录的配置1、输入Jenkins随机生成的口令(控制台获取) 2、执行默认的安装操作(必要的插件，详见文末附录) 3、创建用户，配置密码，邮箱等信息 系统设置shell编码设置管理Jenkins--&gt;系统设置--&gt;全局设置--&gt;环境变量--&gt;配置UTF-8 用于Jenkins内部shell UTF-8编码设置 RSS/Email配置略 构建项目构建一个maven项目略 配置源码仓库输入SVN地址或其他源码仓库地址 配置触发器Jenkins支持多种触发器配置，包括： 1、定期进行构建（Build periodically），定时器使用示例如下： H(25-30) 18 1-5： 工作日下午6点25到30分之间进行build H 23 1-5：工作日每晚23:00至23:59之间的某一时刻进行build H(0-29)/15 ：前半小时内每隔15分钟进行build（开始时间不确定） H/20 ：每隔20分钟进行build（开始时间不确定） 2、根据提交进行构建（Build when a change is pushed to GitHub） 3、定期检测代码更新，如有更新则进行构建（Poll SCM） 配置SonarQube1、点击“增加构建后操作步骤”，新增Sonar([什么是Sonar](https://www.ibm.com/developerworks/cn/java/j-lo-sonar/ &quot;什么是Sonar&quot;)) 2、配置Sonar(JDK等) 配置自动化部署1、输入war包存放路径 一般存放在Jenkins的{%Jenkins_dir%}\\jobs\项目名\workspace\target目录下(根据JENKINS版本不同可能会不一样，当前版本2.91) 2、配置Context path，即项目的访问根地址，比如localhost:8080/根地址 3、新增容器，选择tomcat。(插件支持部分容器，如果需要发布到其他web容器，可考虑让容器与maven集成，使用mvn命令部署) 4、输入tomcat账号、密码(admin)、访问IP:端口 构建完成以上配置后，保存，回到Jenkins首页，点击项目列表最右方的构建按钮，开始构建 查看构建状态点击左下角构建编号，下拉选择ConsoleOutput，即可查看构建状态 查看代码检测结果构建完成后，下拉项目，选择sonarqube，可以看到代码检测结果 总结无 未完待续附：实用插件OS专用：Xcode integration Android专用：Gradle plugin Gitlab插件：GitLab Plugin 和 Gitlab Hook Plugin Git插件： Git plugin GitBuckit插件： GitBuckit plugin 签名证书管理插件: Credentials Plugin 和Keychains and Provisioning Profiles Management FTP插件: Publish over FTP 脚本插件: Post-Build Script Plug-in 修改Build名称/描述(二维码)： build-name-setter / description setter plugin 获取仓库提交的commit log： Git Changelog Plugin 自定义全局变量: Environment Injector Plugin 自定义邮件插件： Email Extension Plugin 获取当前登录用户信息： build-user-vars-plugin 显示代码测试覆盖率报表： Cobertura Plugin 来展示生成的单元测试报表，支持一切单测框架，如junit、nosetests等： Junit Plugin 其它： GIT plugin / SSH Credentials Plugin 本文参考资料：https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000https://www.zhihu.com/question/25385945http://skyseraph.com/2016/07/18/Tools/Jenkins%20Gitlab%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%89%93%E5%8C%85%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/http://blog.csdn.net/liuyuehu/article/details/51532466http://blog.csdn.net/wangmuming/article/details/22924815]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>Jenkins，持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端自动化测试]]></title>
    <url>%2F2017%2F11%2F24%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[背景略 未完待续附：]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端测试思路]]></title>
    <url>%2F2017%2F11%2F24%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[背景针对近半年的测试经验进行简要的总结，部分内容参考了网络上的一些文章 有哪些服务端测试我们公司有哪些服务端的应用： 1、web端的服务，onsite直播平台、云导播、云轮播、拆条、收录等等 2、客户端相关的服务：无 针对以上的这些服务，总结归纳了一下，划分了两种类型： 1、B\S结构，即浏览器\服务器结构，也就是各种web应用，这些web应用只与浏览器有关，他的web页面以及各种后台逻辑均运行在各种服务器上。 2、C\S结构，即客户端\服务器结构，这种产品的客户端需要与服务器端通过接口进行通讯，同时服务器端还有自己的功能逻辑，在接收到客户端发送的请求之后会进行处理，然后返回给客户端。 准备工作针对以上这两种不同结构的服务器端程序，如何进行测试呢？ 首先，制定一套完善的测试流程，通过该流程，指导测试、开发、产品、OP运维等同学的工作。在这个流程中，有三个关键的环节： 准备会议产品需求评审会在这个评审会上，产品会对提出的需求做出详细的讲解，如果各方涉及的人员比较多，还会确定产品负责人、开发负责人、测试负责人。各负责人的职责如下： 1、产品负责人：是这个项目的总负责人，负责各配合方之间的沟通。 2、开发责任人：包括客户端和服务端，原则上由客户端开发为开发的总负责人。 3、测试负责人：包括客户端和服务端，原则上由客户端测试为测试的总负责人。 开发设计实现讲解会在这个环节，开发会在接到需求后，组织一次设计评审，在这里主要由开发（包括前端和后端）和测试参加，在会上我们会做以下几件事情： 1、由开发详细的讲解功能得到设计思路，包括客户端和服务器端的功能实现 2、后续的计划排期 3、在设计阶段就会增加线上的监控机制 经过这两个评审会之后，测试会给出大概的测试方案，待开发提测后，测试就可以展开后续的测试工作。 准备环境测试服务器我们的开发会将编写完成的代码上传到SVN上，所有测试环境中的代码均来自SVN，这样可以保证被测试的代码与SVN上的代码是一致的，与此同时，我们也要不断的关注开发开发SVN上的改动，以便确认测试的范围和后续的验证。 待上线服务器待服务器端的功能测试完毕后，会将被测试完成的代码部署到待上线服务器上，待上线环境的配置与线上环境完全相同。我们会在这台机器上进行性能相关的测试。 线上服务器待性能测试与功能测试均完毕后，测试会将开发提交的代码进行冻结，开发会给OP运维部门提交上线申请单，然后由OP运维部门将SVN中测试完毕的代码部署到线上。待部署完成后，测试会针对线上环境进行上线验证。 准备监控我们会针对线上提供的服务进行监控，主要是该服务的接口功能正确性。 而服务器运行的稳定性是由OP运维部门负责监控。 当发生线上问题时，测试、产品、开发、OP均会收到包括邮件和短信的通知。 测试先进行问题确认，并及时给出结果反馈。 如果有问题，开发和OP会对问题进行排查，并由测试进行验证。 如果没有问题，会查当时通知时发生了什么，以便确认问题是被自动修复了，还是线上监控脚本出现了问题。 如何开展有了上面的测试流程之后，那么在开发提测后，我们是如何进行测试的呢？针对之前提到的两种不同的产品类型，我们会进行以下两方面的测试： 功能测试针对功能测试，我们有两种不同的测试方法： 基于用户层面的黑盒功能测试1、根据产品提出的需求文档，划分功能，拆分需求点，根据需求点，进行对应测试用例的编写； 2、在这个过程中，基本上忽略了客户端与服务器端或前台页面与后台逻辑是如何进行交互的，完全通过客户端或前端页面的行为进行功能测试。 基于代码逻辑和服务器配置的白盒测试服务器端配置的正确性与合理性1、服务器是否有缓存机制； 2、服务器对连接数是否有限制； 3、服务器的负载均衡是否合理； 4、服务器连接的是否有超时设置； 5、各种网络请求是否使用的是内网IP。 接口测试一般情况下客户端与服务器端的数据交互，均是通过http请求完成的。而服务器端通过web服务器将接收到的请求进行处理。这些处理主要围绕着，对数据的存储、运算、转发等操作，并将操作之后的结果反馈给客户端。所以接口功能的正确与否，会直接反映服务器端功能的正确与否。那么，这对接口我们是如何进行测试的呢？ 1、根据该接口的功能，评估该接口定义的合理性与安全性，例如： 1）客户端发送的网络请求是否需要带有时间戳； 2）客户端发送的网络请求是否需要有固定的参数，比如客户端发送的请求中需要带有版本号等信息； 3）客户端发送的数据是否需要进行加密； 4）服务器端是否有针对请求发送来源的校验； 5）服务器端给客户端返回的数据及状态码是否合理。 2、接口的测试方法 通过编写测试脚本，针对接口进行测试，步骤一般是这样的： 1）根据接口定义的参数，确认传输的参数都有哪些，可能的正常取值和异常取值； 2）通过脚本模拟客户端发送网络请求，对接口进行单独测试，并对服务端返回的结果数据进行自动化校验； 3）通过脚本构造用户的一系列操作，用以验证系统功能的可用性。 3、代码功能逻辑测试 1）对服务器端的代码做静态代码走查，主要关注以下内容： 1.定义的变量是否都被初始化； 2.服务器是否有针对客户端发送的数据进行异常校验； 3.对数据库的操作是否有未释放的情况； 4.服务器端的判断逻辑是否存在功能隐患； 5.连接的数据库环境是否正确； 6.对数据库的操作是否有关闭操作。 2）通过编写单元测试用例进行验证 性能测试制定方案依据需求，明确测试目的 围绕测试目的来制定测试方案，测试方案要明确需要关注的性能参数、测试方法，确定要使用的工具 最后要考虑到整个测试流程中可能存在的影响结果准确性的风险点（网络波动、CDN与SLB配置等非平台因素） 以下是之前进行直播平台性能测试的简单测试方案 选择压力生成工具服务器压力测试工具有很多，也可以自己写适合性能测试场景的压力生成脚本 较为常用的压力测试工具： Jmeter LoadRunner ab st_load 以上测试工具的简单使用方法参照本博客其他文章，《ab下载与上传压测》，《st-load安装与使用》 选择监控工具监控工具也有很多，也可以需求写适合性能测试场景的监控脚本，重点提取需要关注的性能参数 运维监控工具Zabbix等 nmon 以上部分工具的简单使用，参考本博客其他文章，《Nmon使用总结》 测试环境准备1、明确各个模块集群内部的服务器配置：基本的有内存、CPU、磁盘以及网络带宽等等 2、部署测试环境，也可以编写自动化部署脚本（ansible）或者使用容器（docker、kubernetes）快速部署 3、系统流程调试，确保系统底层功能正确无误 测试脚本准备考虑到压力机系统瓶颈，测试过程中可能需要多台压力机同时给出压力，为提高测试效率以及避免操作失误，需准备测试脚本 编写测试脚本可采用脚本语言亦可采用编程语言 shell expect python等 expect脚本在压力测试中的简单使用参考本博客中《Linux下expect脚本语言的简单使用》 执行测试渐增加压，达到一定程度观察系统稳定性，观察资源消耗以及系统响应情况 单台1、在一定的配置与系统环境下，得出模块单台服务器的系统性能 2、若有条件，在以上基础上对程序内部单个接口进行压测 3、定位瓶颈并给出优化意见 集群1、在一定的配置与系统环境下，得出模块集群服务器的系统性能 2、SLB配置（带宽峰值、调度算法、会话保持等）、内网带宽等 3、定位瓶颈并给出优化意见 系统1、在一定的配置与系统环境下，得出平台整体的系统性能 2、入出口SLB配置（带宽峰值、调度算法、会话保持等）、内网带宽与外网带宽、CDN命中率等 3、定位系统瓶颈并给出优化意见 数据库等其他模块1、压测过程中观察系统与数据库交互情况，排查数据库是否可能是系统瓶颈点 2、硬件、操作系统、数据库配置、应用模型、引擎选择等 参考资料http://blog.csdn.net/wlly1/article/details/51357306 https://www.zhihu.com/question/20694803 https://www.cnblogs.com/zhuque/archive/2013/03/15/2961953.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>服务端测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习总结]]></title>
    <url>%2F2017%2F11%2F23%2Fpython%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景略 python简介略 基础有什么环境部署略 中文编码1、python中默认的编码格式是ASCII格式 2、若程序中有中文，需在文件开头加入# -- coding: UTF-8 -- 或者 #coding=utf-8 3、python3.X源码文件默认使用utf-8编码，无需指定utf-8编码 基础语法1、python编程方式 交互式编程：不需要创建脚本文件，通过python解释器的交互模式进行代码编写 脚本式编程：通过脚本参数调用解释器执行脚本，脚本执行完毕后，解释器就不再有效 2、标识符 编程语言的标识符大同小异 数字、字母、下划线 区分大小写 不能以数字开头 _test，以单下划线开头的标识符是不能直接访问的类属性，不能用from XXX import *导入，需要通过类提供的接口进行访问 __test，以双下划线开头的标识符代表类的私有成员、 __test__，以双下划线开头和结尾的标识符代表特殊方法专用的标识，比如__init__()标识类的构造函数 3、保留字符 保留字符可以理解为关键字，保留字符不能被当成常数或者变数，或者是其他任何标识符的名称 ![](https://i.imgur.com/7TXDfmp.png) 4、缩进 python对格式要求非常严格，因为python使用缩进来写模块，不像java需要用大括号{}来控制类、方法和其他的一些逻辑判断 缩进的空白数量可变，但是所有的**代码块语句的缩进空白数量必须保持相同** 5、其他 多行连接符 \ 若语句中包括[]、{}或者()就不需要使用多行连接符进行换行 引号 &apos;&apos;、&quot;&quot;、&apos;&apos;&apos; &apos;&apos;&apos;、&quot;&quot;&quot; &quot;&quot;&quot; 其中三引号可以由多行组成，多行文本的快捷语法经常被用在文件的特定地点，被当做注释来使用 注释 # #用做单行注释 三引号常用作多行注释 空行 空行用来分隔两段不同功能或含义的代码，便于代码维护或重构 一行显示多条语句 ; 如果想在同一行会用多条语句，需要在语句之间使用分号分隔 等待输入 下方语句执行后就会等待用户输入，按回车键后就会退出程序 raw_input(&quot;\n\nPress the enter key to exit.&quot;) Print输出 使用Print进行输出，默认都是换行的，如果想要不换行输出，需要在变量末尾加上逗号 python -h 用来查看各参数帮助信息 变量类型标准数据类型 Number（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 涉及数据类型转换时，可以采用内置函数进行数据类型转码，只需要将数据类型作为函数名，将待转换内容作为参数输入即可 数字数字数据类型用来存储数值，是不可变的数据类型 使用del语句删除对象的引用 python支持四种数字类型 int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） python中使用L来表示长整型，避免使用l与数字1产生混淆 复数由实数部分和虚数部分构成，可表示为a+bj,或者complex(a,b)，复数的实部a和虚部b都是浮点型 字符串字符串由数字、字母和下划线组成的一串字符 一般有两种取值顺序： 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 例： s = &quot;letusmaketest&quot; s1 = s[5]的结果是m s2 = s[9]的结果是t s3 = s[5:9]的结果是make s4 = s[:9]的结果是letusmake s5 = s[5:]的结果是maketest 上面的s3结果包含s[5]的值m，但是不包括s[9]的值t。 加号（+）是字符串连接运算符，比如s + &apos;test&apos; 星号（*）是重复操作，比如s * 2表示s连续输出两次 列表列表是Python中使用最频繁的数据类型 列表可以完成大多数集合类的数据结构实现，支持数字、字符、字符串甚至包含列表（嵌套） 列表中值的切割也可以使用 [头下标:尾下标]的方式，规则和字符串切割取值相同 加号和星号操作与字符串相同 列表可以二次赋值 元组元组和列表类似 元组使用()标识，内部元素用逗号隔开 元组不能二次赋值，相当于只读列表 字典字典是除列表之外Python中最灵活的内置数据结构类型 字典是无序的对象集合，列表是有序的对象集合 字典和列表的区别：字典中的元素是通过键来存取，而列表中的元素是通过偏移来存取 字典用&quot;{}&quot;标识，字典由索引(key)和它对应的值value组成 例： testDic = {} testDic[&apos;test1&apos;] = &apos;This is test1&apos; testDic[2] = &apos;This is test2&apos; testDic2 = {&apos;name&apos;: &apos;huangyl&apos;,&apos;age&apos;:25, &apos;sex&apos;: &apos;man&apos;} print testDic[&apos;test1&apos;] #输出键为&apos;test1&apos;的值 print testDic[2] #输出键为2的值 print testDic2 #输出字典testDic2 print testDic2.keys() #输出字典testDic2的所有键 print testDic2.value() #输出字典testDic2的所有值 基本语句大同小异，基本语句包括： 1、条件语句 2、循环语句 基本分类 1）for循环 2）while循环 3）嵌套循环 控制语句 1）break语句 2）continue语句 3）pass语句 条件语句基本形式： if 判断条件： 执行语句…… else： 执行语句…… 显而易见，如果满足条件，就do A，如果不满足，就do B 以上需要注意的几点： 1、else是可选语句，当需要在条件不成立时执行内容则可以执行相关语句 2、Python不支持switch语句，多个条件判断，只能用elif来实现，即判断条件a后又继续对条件b做了判断 3、需同时判断多个条件时，可判断组合条件。当有多个条件时，判断优先级顺序为：括号&gt;大于/小于&gt;与/或/非 循环语句Python中提供了for循环和while循环以及两种循环的组合形式嵌套循环 Python支持以下循环控制语句： break语句：在语句块执行过程中终止循环，并且跳出整个循环 continue语句：在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环 pass语句：pass是空语句，是为了保持程序结构的完整性 while基本形式： while 判断条件： 执行语句…… else 执行语句…… 其中： 1、执行语句可以是单个语句也可以是语句块 2、判断条件可以是任何表达式，任何非零、或非空的值均为ture 3、若无else语句，当判断条件为false时，循环结束；若有else，当判断条件为false时，将执行else语句 4、如果判断条件永远为true，循环将会无限的执行下去 for基本形式： for iterating_var in sequence: statements(s) break else: 执行语句…… 其中： 1、Python中for循环可以遍历任何序列的项目，如一个列表或者一个字符串 2、另外还有一种执行循环的遍历方式是通过索引进行遍历 3、若无else语句，for循环会在遍历完成后退出；若有else语句，else语句会在循环正常执行完成的情况下执行 循环嵌套while循环嵌套基本形式： while expression: while expression: statement(s) statement(s) for循环嵌套基本形式： for iterating_var in sequence: for iterating_var in sequence: statements(s) statements(s) 其中： 1、while与for循环体可以互相嵌套 break1、break语句用在while和for循环中，用来跳出整个循环 2、break语句用来打破最小封闭for或者while循环 3、使用break终止循环语句时，即便循环条件没有false或者序列没有完全递归完，也会停止执行循环语句 4、在嵌套循环中，break语句将停止执行最深层的循环，并开始执行下一行代码 continue1、continue语句用在while和for循环中，用来跳出本次循环，跳过当前循环的剩余语句，继续进行下一轮循环 2、无 pass1、pass是空语句，为了保持程序结构的完整性 2、pass不做任何事情，一般用作占位语句 什么是函数什么是函数1、什么是函数 1）函数是啥，函数就是函数。。。 2）函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段 3）函数能提高应用的模块性，和代码的重复利用率 4）Python提供了很多內建函数，如len()、range()和print()等 5）用户自己创建的函数，叫做用户自定义函数 2、函数的语法格式 基本形式： def functionname( parameters ): &quot;函数_文档字符串&quot; function_suite return [expression] 其中： 1）函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 2）任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 3）函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 4）函数内容以冒号起始，并且缩进。 5）return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 函数调用1、函数被定义后，指定了函数的名称、包含的参数以及代码块结构 2、调用函数时，写全函数名以及传入的参数 参数数据类型与对象1、万物皆对象 2、Python中，对象具有类型，而变量是没有类型的（变量可以理解为对象的引用或者指向对象存储区域的一个指针） 3、在python中创建参数时，会在内存中创建一块区域，存储该数据类型对象的值，同时会有一个指针（变量）来指向该内存区域 可更改与不可更改1、数字(number)、字符串(string)、元组(tuples)是不可更改的对象，而数组(list)、字典(dict)是可以修改的对象 2、对于可变与不可变类型的解释： 不可变类型： 变量赋值a=5后再赋值a=10，这里实际是新生成一个 int值对象10，再让a指向它，而5被丢弃，不是改变a的值，相当于新生成了对象，再让a指向新的对象。 可变类型： 变量赋值la=[1,2,3,4]后再赋值la[2]=5，则是将list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 3、Python传参类似c++的值传递 不可变类型：传递整数、字符串、元组类型的对象。 例：fun（a），传递的只是a的值，没有影响a对象本身。如果在fun（a）内部修改a的值，只是修改另一个复制的对象，不会影响外部的a本身。 可变类型：传递列表、字典类型的对象 例：fun（la），则是将la真正的传过去，修改后fun外部的la也会受影响 4、python中一切都是对象，严格意义不能说值传递还是引用传递，应该说传不可变对象和传可变对象 Python中函数参数的传递是传递的变量的值。 不可变对象作为函数参数，相当于C系语言的值传递。 可变对象作为函数参数，相当于C系语言的引用传递。 调用函数使用的正式参数类型必备参数： 关键字参数： 默认参数： 不定长参数 未完待续]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNA方式调用dll动态库]]></title>
    <url>%2F2017%2F11%2F19%2FJNA%E8%B0%83%E7%94%A8dll%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[背景之前有段时间写了个GUI，调用公司CA服务器相关接口，进行两码获取、证书下载等操作，证书下载需要借助动态链接库等控件进行，故有如下内容 JNA是什么java调用dll较为常用的方式有JNA和JNI。 JNA是建立在JNI技术基础之上的一个Java类库，我们可以方便地使用java直接访问动态链接库中的函数。 原来使用JNI，必须手工用C写一个动态链接库，在C语言中映射Java的数据类型。 而JNA提供了一个动态的C语言编写的转发器，可以自动实现Java和C的数据类型映射，我们不再需要编写C动态链接库。 怎么用过程： 1、引入JNA.jar 2、声明接口（注意和动态库方法数据类型的映射关系） 3、调用声明的接口中的方法 调用时需要注意dll的位置： 方式一：把动态库拷贝到system32目录 方式二： String path = ESAMServer.class.getResource(&quot;/&quot;).getPath()+&quot;/dll&quot;; System.load(path+&quot;/MyNative.dll&quot;); NativeLibrary.addSearchPath(&quot;MyNative.dll&quot;, path); 测试代码JComboBoxTest.javapackage TestNativeLibrary; import java.awt.BorderLayout; import java.awt.GridLayout; import javax.swing.DefaultComboBoxModel; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JTextArea; public class JComboBoxTest { private JFrame frame = new JFrame(&quot;JComboBoxTest&quot;); private JPanel panel1 = new JPanel(new BorderLayout()); private JComboBox JComboBoxT = new JComboBox(); private JTextArea JTextAreaT = new JTextArea(); public JComboBoxTest(){ JNATest jc = JNATest.instanceDll; frame.setLayout(null); frame.setLayout(new GridLayout(1,1)); frame.setVisible(true); frame.setBounds(400, 250, 200, 150); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComboBoxT.setModel(new DefaultComboBoxModel(jc.rsa_csp_listProvider())); frame.add(panel1); panel1.add(&quot;North&quot;,JComboBoxT); panel1.add(&quot;Center&quot;,JTextAreaT); } public static void main(String args[]){ new JComboBoxTest(); } } JNATest.javapackage TestNativeLibrary; import com.sun.jna.Library; import com.sun.jna.Native; public interface JNATest extends Library { public JNATest instanceDll = (JNATest)Native.loadLibrary(&quot;SKFCSPEnroll&quot;, JNATest.class); public String[] rsa_csp_listProvider(); } 附：参考： http://blog.csdn.net/hengwei_vc/article/details/6982076 http://blog.chinaunix.net/uid-29308108-id-4048576.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态链接库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker kubernetes]]></title>
    <url>%2F2017%2F11%2F13%2Fdocker-kubernetes%2F</url>
    <content type="text"><![CDATA[背景略 kubernetes]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>自动化部署</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下php项目安装与部署]]></title>
    <url>%2F2017%2F11%2F08%2Flinux%E4%B8%8Bphp%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[背景云收录测试需要，内网原环境由开发和测试共同使用，为避免使用冲突以及确保测试的准确性，需重新部署。在此记录部署过程以及遇到的一些代表性问题。 rpm方式安装yum源配置若yum源已配好，此步略过。 国内开源社区提供了很多yum源地址，常用的163、阿里等等 yum 或者 rpm安装配置yum源 yum cache，yum clean，yum update php+mysql+http等等，nginx可选，通过web访问的提示错误，安装缺少的依赖包（pip等等） yum error rpmts_HdrFromFdno:V3 RSA/SHA1 Signature,key ID c105b9de:NOKEY解决方法：依据linux系统版本，导入相应rpm的签名信息 1、先安装如下工具包： rpm -Uhv http://dag.wieers.com/packages/rpmforge-release/rpmforge-release-0.3.4-1.el4.rf.i386.rpm rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-6 2、一般来说安装完上面的工具包后即可，如果还是不行，查看编辑yum源文件：替换RPM-GPG-KEY-CentOS-5，替换为对应的key文件名：RPM-GPG-KEY-CentOS-6（要全部替换）。 或者以root登录，执行rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release。我的Linux版本是CentOS 6.5，rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 安装软件包1、安装php 2、安装httpd 3、安装mysql 4、安装nginx 5、启动，根据错误信息提示，缺什么装什么 源码方式安装php安装1、下载源码包，此次使用php-5.6.30 2、解压至/usr/local 3、编译安装（./configure，make，make install），若没有gcc环境，要先进行安装 4、启动，根据错误提示信息，缺什么装什么 apache安装1、下载源码包，此次使用httpd 2.4.4。httpd 2.4.4需要较新版本的apr和apr-util，本次使用 apr-1.4.6.tar.bz2与apr-util-1.5.2.tar.bz2版本，注意保证系统时间正确。apr和apr-util的下载路径为：http://archive.apache.org/dist/apr/ 2、解压至/usr/local 3、编译安装（./configure，make，make install） 4、启动，根据错误提示信息，缺什么装什么 4、web访问，根据错误提示信息，缺什么装什么 安装mysql1、yum install mysql 2、启动，根据错误提示信息，缺什么装什么 相关错误以及解决方法PHP提示Call to undefined function mb_substr()解决方法1、打开/etc/php.ini，把extension=php_mbstring.so的注释打开。 2、安装php_mbstring 包 rpm -ivh php-mbstring-4.3.9-3.8.i386.rpm service httpd restart 3、安装完以后需要重启下apache. 解决httpd: Could not reliably determine the server’s fully qualified domain name1、把httpd.conf里面的 #ServerName localhost:80 注释去掉。 2、执行 httpd 3、通过浏览器访问 http://localhost:80 ，如果页面显示 “It works！” ，即表示apache已安装并启动成功。 Python,Django安装MySQLdb各种经典错误(Error No module named MySQLdb)1、缺少MySQLdb模块，可在命令行python中验证。 &gt;&gt;&gt;import MySQLdb 如果报错则没有MySQLdb模块，需安装mysql相关模块。 2、MySQLdb命名错误 参考：http://blog.csdn.net/angel20082008/article/details/26394571[http://blog.csdn.net/angel20082008/article/details/26394571](http://blog.csdn.net/angel20082008/article/details/26394571 &quot;Python,Django安装MySQLdb各种经典错误&quot;) Ppip安装mysql-python报致命错误：my_config.h：没有那个文件或目录yum install mysql-devel 后记： 采用LAMP进行安装部署，网上很多安装教程！！！]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的使用]]></title>
    <url>%2F2017%2F11%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景略 正则表达式简介啥是正则表达式正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式能干啥正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 正则表达式是烦琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本教程，加上应用的时候进行一定的参考，掌握正则表达式不是问题。 许多程序设计语言都支持利用正则表达式进行字符串操作。 使用示例总结功能强大，特别有用！ 附： 参考资料：http://www.runoob.com/regexp/regexp-operator.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xscan漏扫工具的使用]]></title>
    <url>%2F2017%2F10%2F18%2F%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B8%8Exscan%E6%BC%8F%E6%89%AB%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景略 xscan有什么功能采用多线程方式对指定IP地址段(或单机)进行安全漏洞检测，支持插件功能。扫描内容包括：远程服务类型、操作系统类型及版本，各种弱口令漏洞、后门、应用服务漏洞、网络设备漏洞、拒绝服务漏洞等二十几个大类。对于多数已知漏洞，工具都有相应的漏洞描述、解决方案及详细描述链接。 安装与使用安装1、直接google或百度，下载X-Scan，我使用的是X-Scan-v3.3 2、安装X-scan需安装WinPCap驱动程序（什么是WinPCap，以及WinPCap的功能作用，参考百度百科） 使用1、“设置”修改扫描IP或者网段 2、“设置”修改扫描参数，可修改内容包括开放的服务端口，Telnet、SSH、FTP、SQL-Server等协议弱口令以及IIS编解码漏洞等扫描配置内容 3、“设置”修改扫描报告格式，可选html、txt、xml 4、开启任务，可实时监测扫描过程中的普通信息、漏洞信息（开放的服务、端口以及协议类型）、错误信息等内容 总结简单好用，基本满足日常工作使用！ 附： telnet命令：http://www.runoob.com/linux/linux-comm-telnet.html]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>xscan</tag>
        <tag>安全测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab下载与上传压测]]></title>
    <url>%2F2017%2F10%2F18%2Fab%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%B8%8A%E4%BC%A0%E5%8E%8B%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[背景略 简要命令下载ab -n 10000 -c 100 “文件地址” 上传ab -n 10000 -c 100 -T ‘multipart/form-data; boundary=w-QORJuFrcHc6Rwz-RLnKvbtgOIOn0m8mM2DQ’ -p ./abpost.txt “上传接口地址” 上传压测操作方法1、修改abpost.txt内容 1）Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;huangyl.png&quot;，依照例子进行修改 2）Content-Type: MIME，具体格式由上传的文件决定，参考常见的MIME类型 3）对上传的文件进行base64编码，可采用在线转换base64，图片在线转换地址http://tool.css-js.com/base64.html 4）无 2、将abpost.txt放置在执行ab命令的目录下 3、修改总请求数和并发请求数，回车，执行命令 abpost.txt内容--w-QORJuFrcHc6Rwz-RLnKvbtgOIOn0m8mM2DQ Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;huangyl.png&quot; Content-Type: image/png iVBORw0KGgoAAAANSUhEUgAAAkgAAAFmCAYAAACWUGV0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAP+lSURBVHhe7L11lB1Xeq+t+8dd37130GzLFtiWZBJYZmaSmWYyPJnkZjKUDCRjkkEM3S01MzMzMzMzd4tZMtszSb7v/X6/vWufU+f0aant8SSTxL3Ws4rhVFfVfurdtOj/bX5AFK33y0TG7ZK7e7X8w7dukqfvWSVP3HWNPHTbtfLAbdfLfbeulntvXSt337JO7rxlvebmm+SOs3DnLTfPy1233uLktlvPyt233yb33HGb3HfnbXL/nbfLg3fd7Qci8jJUHITPWTSFlKKJxskJYUQU5asiE9mXKVjGTKy0ihvMwUys9MNWSl8rllskNhFLaVHCWtVRQdS3KPLsVhpLeZIsXZXzln2cA732G/kR6X4uxHy5jthG/bN49/3S6hFvDm8fbZXG/5fP3l8bWI6zEnHdcqX7N6TbvXfLxLhoPeD0HXPq5zudZlveYaN3jXuRJ4nWM/eZ+jEXn8Fv5zFoug5duLoO0dAeHX8f8cgo41GkHL/1II//2de8263+zr1tzfGQI6GwSlIP9/IllCWUEWlRdkU3lhNlUU5VBlca5QVZJH1aA0/xdLbVkBjRvcky655BKpVoMYGX6g/x/H/Eel0xKsRgAAAABJRU5ErkJggg== ----w-QORJuFrcHc6Rwz-RLnKvbtgOIOn0m8mM2DQ-- 附：常见的MIME类型(通用型)： 超文本标记语言文本 .html text/html xml文档 .xml text/xml XHTML文档 .xhtml application/xhtml+xml 普通文本 .txt text/plain RTF文本 .rtf application/rtf PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 任意的二进制数据 application/octet-stream]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ab</tag>
        <tag>性能工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试的层级]]></title>
    <url>%2F2017%2F10%2F16%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E5%B1%82%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[背景接《自动化测试的适用范围》 会用工具就是自动化测试工程师吗会使用自动化测试工具的测试人员不能够称之为完全的自动化测试人员，这类测试人员被称为工具小子(Script Kid)。这个阶段还是处于自动化测试的一个比较低级的阶段，因为这些工具都不是测试人员开发的。 对于高手来说，要能写一些独立的测试脚本甚至测试工具。更高的高手则是能脚本和工具和实际工作紧密结合起来，解决工作中遇到的问题。 哪些可以做自动化测试：单元测试单元测试无疑是最适合做自动化的。大多数单元测试是由研发人员完成，测试人员可以不做单元测试，但是可以推动研发人员来编写单元测试用例 单元测试框架1、单元测试常用的框架有很多，比如Java的JUnit，PHP的PHPUnit，Python的unittest等 2、设计自动化单元测试测试用例时一个测试用例通常由三部分组成：setUp，测试逻辑和tearDown，其中setUp用于准备测试数据，tearDown用于清理数据 3、一般单元测试框架都支持装饰器设计模式的注解，比如跳过执行，测试套件的组织，测试用例依赖管理等等 4、单元测试框架可以无缝地在UI测试和接口测试中使用，它们的基本思想都是相通的。 接口测试接口的自动化是目前最适合测试工程师进行自动化的一层。 接口不但变化小，运行速度快，受益高，还有着出现问题后能够很快定位的优点。 UI测试目前，大众眼中关注的比较多的是UI的自动化测试，这是由大家的思维惯性导致的。 传统的测试行业，测试工程师都是从UI下手，来完成所有的测试工作，所以到自动化领域，大家也理所当然的喜欢从UI层来进行自动化。 做UI自动化，最重要的是要能有一个好的自动化测试框架，这里有一些框架的基本设计思路供大家参考： 分布式case增加到一定程度后，如何快速的运行所有的case，这就涉及到分布式的概念。对于Selenium，官方提供了一个Grid，感兴趣的同学可以研究一下。 行为驱动行为驱动就是常说的Cucumber 关键字驱动由『操作对象』、『操作』、『数据』关键字组合成测试用例，框架来把关键字解析为脚本并执行。这种框架最大的优点就是可以提供给不懂代码的测试人员使用，典型的代表是Robot framwork 数据驱动同一段代码的业务逻辑通过更换数据输入来生成多个测试用例，我们只需维护测试数据就可以维护case，这种框架思想在很多测试工具中都有实现 关键字和数据混合驱动较为复杂的测试框架框架，将上述两种框架结合了起来当然，这些思路不仅仅能用在UI层的自动化。对于UI自动化，可以选择只做冒烟测试用例的自动化，这样既可以从UI的角度来重复性的验证主业务主流程没有问题，又可以降低维护成本。 有阅读价值的资料《在做自动化测试之前你需要知道的》https://www.cnblogs.com/fnng/p/3653793.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置http和https代理]]></title>
    <url>%2F2017%2F09%2F19%2Fnginx%E9%85%8D%E7%BD%AEhttp%E5%92%8Chttps%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景近期直播类产品更新，出于安全考虑，播放地址由http转换为https。测试环境部署过程中出现一些小波折，特此记录。 nginx安装部署下载相应安装包，执行以下脚本： #!/bin/bash yum -y install gd-devel yum -y install perl-ExtUtils-Embed yum -y install perl-CPAN yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel tar xf nginx_mod_h264_streaming-2.2.7.tar.gz -C /usr/local/ sed -i &apos;158,161s@^@//@g&apos; /usr/local/nginx_mod_h264_streaming-2.2.7/src/ngx_http_streaming_module.c useradd www -s /sbin/nologin tar xvf nginx-1.7.8.tar.gz cd nginx-1.7.8 ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_gzip_static_module --with-http_dav_module --with-http_addition_module --with-http_realip_module --with-http_flv_module --with-http_mp4_module --with-http_ssl_module --with-http_perl_module --with-debug --with-http_image_filter_module --add-module=/usr/local/nginx_mod_h264_streaming-2.2.7 make make install #cp -rf nginx.conf /usr/local/nginx/conf #mkdir vhosts #cp zy.conf /usr/local/nginx/conf/vhosts 直播间添加特定字段做区分简单采用rewrite进行配置，详细如下： server{ listen 80; server_name 192.168.0.179; root /; location ~ \.m3u8 #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).m3u8$ http://192.168.0.104/$1/$6.m3u8 break; } location ~ \.ts #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).ts$ http://192.168.0.104/$1/$6.ts break; } } 播放地址由http转换为https需注意nginx编译时有无相应的openssl库文件，ldd nginx查看。 简单采用rewrite进行配置，详细如下： server{ listen 443 ssl; server_name 192.168.0.179; ssl on; ssl_certificate ssl/server.crt; ssl_certificate_key ssl/server.key; keepalive_timeout 60; access_log logs/ssl-access.log; error_log logs/ssl-error.log; root /; location ~ \.m3u8 #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).m3u8$ http://192.168.0.104/$1/$6.m3u8 break; } location ~ \.ts #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).ts$ http://192.168.0.104/$1/$6.ts break; } } 附：证书生成openssl genrsa -des3 -out server.key 1024 openssl req -new -key server.key -out server.csr cp server.key server.key_bak openssl rsa -in server.key_bak -out server.key openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iperf的简单使用]]></title>
    <url>%2F2017%2F08%2F23%2Fiperf%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景略 简要命令下载安装配置好yum源，直接安装iperf 使用1、UDP 模式 服务器端 iperf -u -s 客户端 iperf -c 服务端IP -u -P 1 -i 1 -p 5001 -f M -b 45M -t 20 -T 10 在udp模式下，以45Mbps为数据发送速率，客户端到服务器上传带宽测试，测试时间为20秒。 iperf -u -c 192.168.1.1 -b 5M -P 30 -t 60 客户端同时向服务器端发起30个连接线程，以5Mbps为数据发送速率。 iperf -u -c 192.168.1.1 -b 100M -d -t 60 以100M为数据发送速率，进行上下行带宽测试。 2、TCP模式 服务器端 iperf -s 客户端 iperf -c 192.168.1.1 -P 1 -i 5 -p 5001 -f M -t 120 在tcp模式下，客户端到服务器192.168.1.1上传带宽测试，测试时间为120秒。 iperf -c 192.168.1.1 -P 30 -t 60 客户端同时向服务器端发起30个连接线程。 iperf -c 192.168.1.1 -d -t 60 进行上下行带宽测试。 注意1、测试htb的时候最好用udp，udp通信开销小，测试的带宽更准确 2、带宽测试通常采用UDP模式，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为100Mbps，先用 -b 100M进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>性能工具</tag>
        <tag>iperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个常用性能测试工具]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[实践出真知，好不好，只有用用才知道。 几个常用性能测试工具Web BenchWeb Bench是一个简单的web或者web代理服务的基准测试工具。（它）使用fork()模拟多个客户端并且可以发起HTTP/0/9-HTTP/1.1的请求。这个基准测试不是非常符合实际情况，但是可以测试出你的HTTP服务是否可以处理多个客户同时访问而不会把你的机器弄挂掉。这个工具可以获得服务的两个指标：每分钟响应请求数量（pages/min）和每秒钟传输数据量（bytes/sec）。使用-f选项可以运行在主动模式下（不等待服务器响应直接发送下一个请求）。 安装方法参考：（总结）Web性能压力测试工具之WebBench详解 abab即Apache HTTP server benchmarking tool ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。ab命令对发出负载的计算机要求很低，既不会占用很高CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。 ab的用法参考：ab - Apache HTTP server benchmarking tool，（总结）Web性能压力测试工具之ApacheBench（ab）详解 SiegeSiege（英文意思是围攻）是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。 Siege 支持基本的认证，cookies， HTTP 和 HTTPS 协议。 Siege的安装和用法可以参考：Siege Manual，Using Siege to Tune Apache on GNU/Linux，（总结）Web性能压力测试工具之Siege详解，压力测试工具siege的用法 Apache JMeter什么是jmeterApache JMeter是一个专门为运行和服务器装载测试而设计的、100％的纯Java桌面运行程序。原先它是为Web/HTTP测试而设计的，但是它已经扩展以支持各种各样的测试模块。它和用于HTTP和SQL数据库（使用JDBC）的模块一起运送。它可以用来测试静止资料库或者活动资料库中的服务器的运行情况，可以用来模拟对服务器或者网络系统加以重负荷以测试它的抵抗力，或者用来分析不同负荷类型下的所有运行情况。它也提供了一个可替换的界面用来定制数据显示，测试同步及测试的创建和执行。 JMeter的工作原理JMeter可以作为Web服务器与浏览器之间的代理网关，以便捕获浏览器的请求和Web服务器的响应，这样就很容易地生成性能测试脚本，有了性能测试脚本，JMeter就可以通过线程组来模拟真实用户对Web服务器的访问压力，这与LoadRunner的工作原理基本一致。 参考资料JMeter的用户手册：http://jmeter.apache.org/usermanual/index.html 推荐一本书籍：《零成本实现Web性能测试》 JMeter的脚本录制工具：Badboy Web PolygraphWeb Polygraph这个软件也是一个用于测试WEB性能的工具，这个工具是很多公司的标准测试工具，包括微软在分析其软件性能的时候，也是使用这个工具做为基准工具的。很多招聘测试员的广告中都注明需要熟练掌握这个测试工具。 TCPCopyTsungcurl-loaderGrinderGrinder是一个开源的JVM负载测试框架，它通过很多负载注射器来为分布式测试提供了便利。 支持用于执行测试脚本的Jython脚本引擎HTTP测试可通过HTTP代理进行管理。根据项目网站的说法，Grinder的 主要目标用户是“理解他们所测代码的人——Grinder不仅仅是带有一组相关响应时间的‘黑盒’测试。由于测试过程可以进行编码——而不是简单地脚本 化，所以程序员能测试应用中内部的各个层次，而不仅仅是通过用户界面测试响应时间。 LoadRunner（商业软件）LoadRunner 是一种预测系统行为和性能的工业标准级负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner 能够对整个企业架构进行测试。通过使用LoadRunner ， 企业能最大限度地缩短测试时间， 优化性能和加速应用系统的发布周期。企业的网络应用环境都必须支持大量用户，网络体系架构中含各类应用环境且由不同供应商提供软件和硬件产品。难以预知的用户负载和愈来愈复杂的应用环境使公司时时担心会发生用户响应速度过慢， 系统崩溃等问题。这些都不可避免地导致公司收益的损失。Mercury Interactive 的 LoadRunner 能让企业保护自己的收入来源， 无需购置额外硬件而最大限度地利用现有的IT 资源， 并确保终端用户在应用系统的各个环节中对其测试应用的质量， 可靠性和可扩展性都有良好的评价。LoadRunner 是一种适用于各种体系架构的自动负载测试工具， 它能预测系统行为并优化系统性能。LoadRunner 的测试对象是整个企业的系统， 它通过模拟实际用户的操作行为和实行实时性能监测， 来帮助您更快的查找和发现问题。此外，LoadRunner 能支持广范的协议和技术， 为您的特殊环境提供特殊的解决方案。 kylinpet（国产商业工具）kylinPET（performance emulation tool，麒麟宠物）是一款功能强大的性能测试工具；界面友好、操作方便，资源占用率低；自带TCP/IP协议栈，支持虚拟大量IP；支持IPv4、IPv6的多种业务测试；支持WEB/WebService业务与Flex（HTTP）、IMS业务（SIP）、IPTV业务（RTSP/IGMP/MLD）、XMPP、Socket业务、数据库、JMS、FTP/SFTP、WEB视频（包括FLV/MP4/HTTP Live Streaming/HTTP Smooth Streaming/HTTP Dynamic Streaming）、WebSocket、JAVA；支持多种协议组合。 总结一些性能测试的做法1、为了减少网络延迟和带宽限制对性能测试的影响，最好在内网进行测试。 2、性能测试一般在优化前和优化后，测试两轮，这样能够比较出优化前后的效果。 3、性能测试最好跑的时间长一些，观察程序是否存在内存泄漏、资源未释放等问题。 4、有的公司为了避免影响线上环境，只在测试环境做性能测试。性能测试一般在线下线上都要做，线上做性能测试可以了解生产环境的性能情况。 参考： http://www.cnblogs.com/EthanCai/archive/2014/05/11/3721656.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>测试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11款常用的web应用框架]]></title>
    <url>%2F2017%2F08%2F10%2F%E5%87%A0%E6%AC%BE%E5%B8%B8%E7%94%A8%E7%9A%84web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[几款常用的web应用框架 Rails 代码托管地址：https://github.com/rails/rails Express 代码托管地址：https://github.com/rails/rails Django 代码托管地址：https://github.com/django/django Meteor 代码托管地址：https://github.com/meteor/meteor CakePHP 代码托管地址：https://github.com/cakephp/cakephp Symfony 代码托管地址：https://github.com/symfony/symfony Sinatra 代码托管地址：https://github.com/sinatra/sinatra Flask 代码托管地址：https://github.com/mitsuhiko/flask Laravel 代码托管地址：https://github.com/laravel/laravel Sails 代码托管地址：https://github.com/balderdashy/sails Revel 代码托管地址：https://github.com/revel/revel 参考文档：https://yusi123.com/3654.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>web应用框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下expect脚本语言的简单使用]]></title>
    <url>%2F2017%2F07%2F24%2FExpect%E4%BA%A4%E4%BA%92%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景最近在做直播服务器性能测试，因单台推流服务器性能限制，需多台机器同时推流，而且要监控直播平台各个底层服务器的性能，手动推流并开启监控繁琐而且易出错，故有如下内容。 什么是Expect介绍Expect是一个用来实现自动交互功能的软件套件。使用它，系统管理员可以创建脚本来对命令或程序进行输入，而这些命令和程序是期望从终端（terminal）得到输入，一般来说这些输入都需要手工输入进行的。Expect则可以根据程序的提示模拟标准输入提供给程序需要的输入来实现交互程序执行。甚至可以实现简单的BBS聊天机器人。 Expect是不断发展的，随着时间的流逝，其功能越来越强大，已经成为系统管理员的的一个强大助手。Expect需要Tcl编程语言的支持，要在系统上运行Expect必须首先安装Tcl。 Expect的四个关键命令：spawn：启动新的进程 expect：从进程接收字符串 send：用于向进程发送字符串 interact：允许用户交互 安装直接使用yum安装相关依赖库以及expect yum install tcl yum install expect 使用pushtestall.sh远程登录启动nmon监控和ffmpeg推流脚本 #!/usr/bin/expect -f set password CDVcloud123 set listnmon /home/huangyl/nmon set listffmpeg /home/huangyl set script loop.sh set timeout -1 #外网登录推流1 spawn ssh root@101.201.237.216 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } #登录入口1,并开启nmon监控 spawn ssh root@172.18.1.14 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录入口2，并开启nmon监控 spawn ssh root@172.18.29.128 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录出口1，并开启nmon监控 spawn ssh root@172.18.29.124 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录出口2，并开启nmon监控 spawn ssh root@172.18.1.15 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口1，并开启nmon监控 spawn ssh root@172.18.1.17 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口2，并开启nmon监控 spawn ssh root@172.18.29.125 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录直播1，并开启nmon监控 spawn ssh root@172.18.1.16 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录直播2，并开启nmon监控 spawn ssh root@172.18.29.127 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录推流1，执行推流命令 spawn ssh root@172.18.1.6 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #登录推流2，执行推流命令 spawn ssh root@172.18.1.9 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #登录推流2，执行推流命令 spawn ssh root@172.18.1.18 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #控制权移交 interact killffmpeg.sh#!/usr/bin/expect -f set password CDVcloud123 #set listnmon /home/huangyl/nmon set listffmpeg /home/huangyl set timeout -1 #外网登录推流1，并杀死ffmpeg spawn ssh root@101.201.237.216 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #内网登录推流2，并杀死ffmpeg spawn ssh root@172.18.1.9 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #内网登录推流3，并杀死ffmpeg spawn ssh root@172.18.1.18 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #控制权移交 interact playtest.shsrs_bench压测 #!/usr/bin/expect -f set password CDVcloud123 set listnmon /home/huangyl/nmon set listbench /home/huangyl/srs-bench-master/objs set usernum 1 set roadname https://zbfee.cdvcloud.com/551016/551016/7t3dmx/g96gwq/06ijj2.m3u8 #set script loop.sh set timeout 30 #登录出口1，打开nmon监控 spawn ssh root@172.18.29.124 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录出口2，打开nmon监控 spawn ssh root@172.18.1.15 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口1，打开nmon监控 spawn ssh root@172.18.1.17 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录接口2，打开nmon监控 spawn ssh root@172.18.29.125 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录srs_bench，开始模拟直播观看 spawn ssh root@172.18.1.6 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listbench\r&quot; expect &quot;*#&quot; send &quot;./sb_hls_load -c $usernum -r $roadname\r&quot; #控制权移交 interact 以上，深深的感受到自动化脚本语言的强大~]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Expect</tag>
        <tag>性能测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对mysql数据库性能测试的相关总结]]></title>
    <url>%2F2017%2F07%2F12%2Fmysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[背景公司针对mysql和mongo开发了相应的数据库管理平台（其实就是包了个壳），需对底层数据库做性能测试，获取相应的性能参数，在此记录测试过程中学到的一些东西 mysql简介mysql是怎么样的数据库mysql关系型数据库 主要功能特性有： 略。 咋用安装略 简单的语句1、查看数据库连接池最大连接数 show variables like &apos;%max_connections%&apos;; 实际MySQL服务器允许的最大连接数16384； 2、设置数据库连接池最大连接数 set global max_connections=1000; 3、show processlist; 如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。 只列出前100条，如果想全列出请使用show full processlist; 4、My.ini配置 虚拟内存 5、查看数据库版本 select @@Version; 6、查看表状态属性 show table status like &apos;表名&apos;; 7、更改表引擎属性 ALTER TABLE test_table1 ENGINE=MyISAM; 8、查看数据库状态 show status; 9、查看数据库状态参数相关命令：show status like &apos;%下面变量%&apos;; show status like &apos;%Aborted_clients%&apos;; 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。 show status like &apos;%Aborted_connects%&apos;; 尝试已经失败的MySQL服务器的连接的次数。 show status like &apos;%Connections%&apos;; 试图连接MySQL服务器的次数。 show status like &apos;%Created_tmp_tables%&apos;;当执行语句时，已经被创造了的隐含临时表的数量。 show status like &apos;%Delayed_insert_threads%&apos;;正在使用的延迟插入处理器线程的数量。 show status like &apos;%Delayed_writes%&apos;; 用INSERT DELAYED写入的行数。 show status like &apos;%Delayed_errors%&apos;; 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。 show status like &apos;%Flush_commands%&apos;; 执行FLUSH命令的次数。 show status like &apos;%Handler_delete%&apos;; 请求从一张表中删除行的次数。 show status like &apos;%Handler_read_first%&apos;;请求读入表中第一行的次数。 show status like &apos;%Handler_read_key%&apos;; 请求数字基于键读行。 show status like &apos;%Handler_read_next%&apos;; 请求读入基于一个键的一行的次数。 show status like &apos;%Handler_read_rnd%&apos;; 请求读入基于一个固定位置的一行的次数。 show status like &apos;%Handler_update%&apos;; 请求更新表中一行的次数。 show status like &apos;%Handler_write%&apos;; 请求向表中插入一行的次数。 show status like &apos;%Key_blocks_used%&apos;; 用于关键字缓存的块的数量。 show status like &apos;%Key_read_requests%&apos;; 请求从缓存读入一个键值的次数。 show status like &apos;%Key_reads%&apos;; 从磁盘物理读入一个键值的次数。 show status like &apos;%Key_write_requests%&apos;;请求将一个关键字块写入缓存次数。 show status like &apos;%Key_writes%&apos;; 将一个键值块物理写入磁盘的次数。 show status like &apos;%Max_used_connections%&apos;;同时使用的连接的最大数目。 show status like &apos;%Not_flushed_key_blocks%&apos;;在键缓存中已经改变但是还没被清空到磁盘上的键块。 show status like &apos;%Not_flushed_delayed_rows%&apos;;在INSERT DELAY队列中等待写入的行的数量。 show status like &apos;%Open_tables%&apos;; 打开表的数量。 show status like &apos;%Open_files%&apos;; 打开文件的数量。 show status like &apos;%Open_streams%&apos;; 打开流的数量(主要用于日志记载） show status like &apos;%Opened_tables%&apos;; 已经打开的表的数量。 show status like &apos;%Questions%&apos;; 发往服务器的查询的数量。 show status like &apos;%Slow_queries%&apos;; 要花超过long_query_time时间的查询数量。 show status like &apos;%Threads_connected%&apos;; 当前打开的连接的数量。 show status like &apos;%Threads_running%&apos;; 不在睡眠的线程数量。 show status like &apos;%Uptime%&apos;; 服务器工作了多少秒。 做测试用到的一些未完待续]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对mongoDB数据库性能测试的相关总结]]></title>
    <url>%2F2017%2F07%2F12%2FmongoDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[背景公司针对mysql和mongo开发了相应的数据库管理平台（其实就是包了个壳），需对底层数据库做性能测试，获取相应的性能参数，在此记录测试过程中学到的一些东西 mongo简介mongodb是怎么样的数据库摘抄网络上的，简单记录下 mongodb是非关系型数据库，它的特点是高性能、易部署、易使用，存储数据非常方便。 主要功能特性有： *面向集合存储，易存储对象类型的数据。 *模式自由。 *支持动态查询。 *支持完全索引，包含内部对象。 *支持查询。 *支持复制和故障恢复。 *使用高效的二进制数据存储，包括大型对象（如视频等）。 *自动处理碎片，以支持云计算层次的扩展性。 *支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 *文件存储格式为BSON（一种JSON的扩展）。 *可通过网络访问。 咋用安装略 启动：/usr/bin/mongod -f /etc/mongod.conf 简单的语句1、删除全部数据 db.Account.remove({}) 2、建表 db.createCollection(&quot;表名&quot;) db.createCollection(&quot;表名&quot;,{capped:true, size:10000}) { &quot;ok&quot; : 1 } 3、查看表数据 db.表名.find() 4、删除数据 db.表名.remove({&quot;字段名&quot;:&quot;字段内容&quot;}) 5、添加用户角色 创建一个可以连接到任何数据库的用户test来查询和写入元数据到testdb db.createUser({user:&quot;test&quot;,pwd:&quot;test&quot;,roles:[&quot;readAnyDatabase&quot;,{role:&quot;admin&quot;,db:&quot;testdb&quot;}]}) 6、删除用户角色 db.dropUser(&quot;test&quot;); 7、多条件查询：db.media.find({&quot;$and&quot;:[{&quot;consumername&quot; : &quot;onair&quot;},{&quot;isdel&quot; : &quot;1&quot;}]}).count() 做测试用到的一些1、大批量插入数据 for(var i=0;i&lt;10000000;i++){ db.test.insert({&quot;name&quot;:&quot;test&quot;+i,&quot;age&quot;:parseInt(i*Math.random())}) } 使用客户端工具如：Robomongo 1.0.0-RC1、NoSQL Manager for MongoDB再或者mongodbmanager执行以上语句灌数据时，灌几万条数据后会报错停止（错误信息忘记记录了），后来写了简单的java代码，使用LR进行执行进行测试数据的灌入 未完待续]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理修改DNS]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%89%B9%E5%A4%84%E7%90%86%E4%BF%AE%E6%94%B9DNS%2F</url>
    <content type="text"><![CDATA[工作中经常要登录线上环境和内网测试环境，手动修改DNS甚是麻烦，特写下如下命令，顺带简单学习下批处理命令： @echo off cls echo 请选择DNS设置为内网（y）or外网（n）： set /p name= if &quot;%name%&quot;==&quot;y&quot; goto Ys if &quot;%name%&quot;==&quot;n&quot; goto No :Ys echo.正在修改dns··· netsh interface ip set dns &quot;本地连接&quot; static 192.168.0.88 primary echo 已设置为192.168.0.88 &gt;nul&amp;&amp;exit :No echo.正在修改dns··· netsh interface ip set dns name=&quot;本地连接&quot; source=dhcp echo 已设置为自动获取DNS &gt;nul&amp;&amp;exit]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于ffmpeg进行转码工具的编写（未完成）]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%9F%BA%E4%BA%8Effmpeg%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考了一些资料，学习过程中尝试写一个转码工具，由于一些个人能力和其他的一些原因暂时搁置，特此记录一些代码，留作参考。 一、GUI： package cn.com.huangyl.tool; import java.awt.BorderLayout; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.Calendar; import java.util.List; import javax.swing.DefaultComboBoxModel; import javax.swing.JButton; import javax.swing.JComboBox; import javax.swing.JFileChooser; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTabbedPane; import javax.swing.JTextArea; import javax.swing.JTextField; public class FFmpegGUI { private JFrame frame = new JFrame(&quot;FFmpegGUI&quot;); private JTabbedPane tabbedPane = new JTabbedPane(); private JPanel panel1 = new JPanel(new BorderLayout()); private JPanel panelx = new JPanel(new BorderLayout()); private JPanel panely = new JPanel(new BorderLayout()); private JPanel panel2 = new JPanel(new BorderLayout()); private JPanel panel3 = new JPanel(new GridLayout(2, 1)); private JPanel panel4 = new JPanel(new BorderLayout()); private JPanel panel5 = new JPanel(new BorderLayout()); private JPanel panel6 = new JPanel(new BorderLayout()); private JPanel panel7 = new JPanel(new BorderLayout()); private JPanel panel8 = new JPanel(new BorderLayout()); private JPanel panel9 = new JPanel(new BorderLayout()); private JPanel panel10 = new JPanel(new BorderLayout()); private JPanel panel11 = new JPanel(new BorderLayout()); private JPanel panel12 = new JPanel(new GridLayout(6,1)); private JPanel panel13 = new JPanel(new GridLayout(6,1)); private JPanel panel14 = new JPanel(new BorderLayout()); private JPanel panel15 = new JPanel(new BorderLayout()); private JPanel panel16 = new JPanel(new BorderLayout()); private JPanel panel17 = new JPanel(new BorderLayout()); private JPanel panel18 = new JPanel(new GridLayout(1,2)); private JPanel panel19 = new JPanel(new BorderLayout()); private JPanel panel20 = new JPanel(new BorderLayout()); private JButton Select = new JButton(&quot;选择&quot;); private JButton StartTranscode = new JButton(&quot;开始&quot;); private JButton Reset = new JButton(&quot;重置&quot;); //private JTextField display = new JTextField(&quot;请点击查询按钮&quot;); private JTextField FilePath = new JTextField(&quot;请选择文件路径&quot;); private JTextField VideoBitrate = new JTextField(); private JTextField resolution = new JTextField(); private JTextField AudioBitrate = new JTextField(); private JTextField AudioSampleRate = new JTextField(); private JTextField CreateFileName = new JTextField(); private JTextField CreateFileFormat = new JTextField(); private JLabel label1 = new JLabel(&quot;请选择文件&quot;); private JLabel label2 = new JLabel(&quot;模板转码&quot;); private JLabel label3 = new JLabel(&quot;请选择模板：&quot;); private JLabel label4 = new JLabel(&quot;自由转码&quot;); private JLabel label5 = new JLabel(&quot;视频码率：&quot;); private JLabel label6 = new JLabel(&quot;分辨率：&quot;); private JLabel label7 = new JLabel(&quot;音频码率：&quot;); private JLabel label8 = new JLabel(&quot;音频采样率：&quot;); private JLabel label9 = new JLabel(&quot;请选择转码方式：&quot;); private JLabel label10 = new JLabel(&quot;留做进度条：&quot;); private JLabel label11 = new JLabel(&quot;生成文件名称：&quot;); private JLabel label12 = new JLabel(&quot;生成文件格式：&quot;); private JComboBox Template = new JComboBox(); private JComboBox TranscodeWay = new JComboBox(); private JTextArea Log = new JTextArea(&quot;&quot;); private JScrollPane scrollPane1 = new JScrollPane(); private JFileChooser stf = new JFileChooser(new File(&quot;d://&quot;)); FFmpegGUI(){ frame.setLayout(null); frame.setBounds(400, 200, 700, 420); frame.setVisible(true); frame.setDefaultCloseOperation(3); tabbedPane.addTab(&quot;ffmpeg&quot;, this.panel1); tabbedPane.addTab(&quot;ffplay&quot;, this.panelx); tabbedPane.addTab(&quot;ffprobe&quot;, this.panely); tabbedPane.setBounds(10, 10, 660, 360); frame.add(this.tabbedPane); panel1.add(&quot;West&quot;,panel2); panel1.add(&quot;Center&quot;,panel19); panel19.add(&quot;Center&quot;,Log); panel19.add(&quot;South&quot;,label10); panel2.add(&quot;North&quot;,panel3); panel2.add(&quot;Center&quot;,panel8); panel3.add(panel4); panel3.add(panel5); panel4.add(&quot;North&quot;,label1); panel4.add(&quot;South&quot;,panel6); panel5.add(&quot;North&quot;,label2); panel5.add(&quot;South&quot;,panel7); panel6.add(&quot;Center&quot;,FilePath); panel6.add(&quot;East&quot;,Select); Template.setModel(new DefaultComboBoxModel(new String[] { &quot;1080p_1920x1080_2000&quot;, &quot;SHD_1280x720_1200&quot;, &quot;HD_960x540_800&quot;, &quot;SD_640x360_500&quot;, &quot;LD_360x240_300&quot;,&quot;...&quot; })); Template.setEditable(false); panel7.add(&quot;Center&quot;,Template); panel7.add(&quot;West&quot;,label3); panel8.add(&quot;North&quot;,label4); panel8.add(&quot;Center&quot;,panel9); panel9.add(&quot;North&quot;,panel10); panel9.add(&quot;Center&quot;,panel11); panel10.add(&quot;West&quot;,panel12); panel10.add(&quot;Center&quot;,panel13); panel12.add(label5); panel12.add(label6); panel12.add(label7); panel12.add(label8); panel12.add(label11); panel12.add(label12); panel13.add(VideoBitrate); panel13.add(resolution); panel13.add(AudioBitrate); panel13.add(AudioSampleRate); panel13.add(CreateFileName); panel13.add(CreateFileFormat); panel11.add(&quot;North&quot;,panel14); panel11.add(&quot;Center&quot;,panel15); TranscodeWay.setModel(new DefaultComboBoxModel(new String[] { &quot;模板转码&quot;, &quot;自由转码&quot; })); TranscodeWay.setEditable(false); panel14.add(&quot;West&quot;,label9); panel14.add(&quot;Center&quot;,TranscodeWay); panel15.add(&quot;Center&quot;,panel16); panel15.add(&quot;South&quot;,panel17); panel17.add(&quot;East&quot;,panel18); panel18.add(Reset); panel18.add(StartTranscode); //文件选择 this.Select.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent event){ FFmpegGUI.this.stf.setFileSelectionMode(0); int state = FFmpegGUI.this.stf.showOpenDialog(null); if(state == 1){ return; } File f = FFmpegGUI.this.stf.getSelectedFile(); FFmpegGUI.this.FilePath.setText(f.getAbsolutePath()); } }); this.StartTranscode.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { String transcodeway = FFmpegGUI.this.TranscodeWay.getSelectedItem().toString(); if (&quot;模板转码&quot;.equals(transcodeway)) { String sourcefile = FFmpegGUI.this.FilePath.getText(); String Template = FFmpegGUI.this.TranscodeWay.getSelectedItem().toString(); FFmpegGUI.this.Log.setText(sourcefile); Transcode t = new Transcode(); } if (&quot;自由转码&quot;.equals(transcodeway)){ String sourcefile = FFmpegGUI.this.FilePath.getText(); String VideoBitrate = FFmpegGUI.this.VideoBitrate.getText(); String resolution = FFmpegGUI.this.resolution.getText(); String AudioBitrate = FFmpegGUI.this.AudioBitrate.getText(); String AudioSampleRate = FFmpegGUI.this.AudioSampleRate.getText(); String CreateFileName = FFmpegGUI.this.CreateFileName.getText(); String CreateFileFormat = FFmpegGUI.this.CreateFileFormat.getText(); Transcode t = new Transcode(); try { t.processTranscodefree(sourcefile,VideoBitrate,resolution,AudioBitrate,AudioSampleRate,CreateFileName,CreateFileFormat); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }); } public static void main(String args[]){ new FFmpegGUI(); } } 二、Transcode package cn.com.huangyl.tool; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class Transcode { /* private static int checkContentType(){ String type = sourcefile.substring(PATH.lastIndexOf(&quot;.&quot;) + 1, sourcefile.length()) .toLowerCase(); //ffmpeg能解析的格式:(asx，asf，mpg，wmv，3gp，mp4，mov，avi，flv等) if (type.equals(&quot;avi&quot;)) { return 0; } else if (type.equals(&quot;mpg&quot;)) { return 0; } else if (type.equals(&quot;wmv&quot;)) { return 0; } else if (type.equals(&quot;3gp&quot;)) { return 0; } else if (type.equals(&quot;mov&quot;)) { return 0; } else if (type.equals(&quot;mp4&quot;)) { return 0; } else if (type.equals(&quot;asf&quot;)) { return 0; } else if (type.equals(&quot;asx&quot;)) { return 0; } else if (type.equals(&quot;flv&quot;)) { return 0; } //对ffmpeg无法解析的文件格式(wmv9，rm，rmvb等),可以先用别的工具（mencoder）转换为avi(ffmpeg能解析的)格式. else if (type.equals(&quot;wmv9&quot;)) { return 1; } else if (type.equals(&quot;rm&quot;)) { return 1; } else if (type.equals(&quot;rmvb&quot;)) { return 1; } return 9; } // 对ffmpeg无法解析的文件格式(wmv9，rm，rmvb等), 可以先用别的工具（mencoder）转换为avi(ffmpeg能解析的)格式. private static String processAVI(int type) { List&lt;String&gt; commend = new ArrayList&lt;String&gt;(); commend.add(&quot;c:\\ffmpeg\\mencoder&quot;); commend.add(sourcefile); commend.add(&quot;-oac&quot;); commend.add(&quot;lavc&quot;); commend.add(&quot;-lavcopts&quot;); commend.add(&quot;acodec=mp3:abitrate=64&quot;); commend.add(&quot;-ovc&quot;); commend.add(&quot;xvid&quot;); commend.add(&quot;-xvidencopts&quot;); commend.add(&quot;bitrate=600&quot;); commend.add(&quot;-of&quot;); commend.add(&quot;avi&quot;); commend.add(&quot;-o&quot;); commend.add(&quot;c:\\ffmpeg\\output\\a.avi&quot;); try { ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); builder.start(); return &quot;c:\\ffmpeg\\output\\a.avi&quot;; } catch (Exception e) { e.printStackTrace(); return null; } } public void processTranscodetemp(String Template,String sourcefile) throws Exception { String type = sourcefile.substring(sourcefile.lastIndexOf(&quot;.&quot;) + 1, sourcefile.length()) .toLowerCase(); String F1080p_1920x1080_2000 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 2000k -r 25 -s 1920x1080 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;1080P_2M.&quot;+type; String SHD_1280x720_1200 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 1200k -r 25 -s 1280x720 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;720P_1200.&quot;+type; String HD_960x540_800 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 800k -r 25 -s 960x540 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;540P_800.&quot;+type; String SD_640x360_500 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 500k -r 25 -s 640x360 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;360P_500.&quot;+type; String LD_360x240_300 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 300k -r 25 -s 360x240 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;240P_500.&quot;+type; if (!checkfile(sourcefile)) { System.out.println(sourcefile + &quot; is not file&quot;); } try{ Runtime rt = Runtime.getRuntime(); Process proc; proc = rt.exec(F1080p_1920x1080_2000); // 取得命令结果的输出流 InputStream fis = proc.getInputStream(); // 用一个读输出流类去读 InputStreamReader isr = new InputStreamReader(fis); // 用缓冲器读行 BufferedReader br = new BufferedReader(isr); String line = null; // 直到读完为止 while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } */ public boolean processTranscodefree(String sourcefile,String VideoBitrate,String resolution,String AudioBitrate,String AudioSampleRate,String CreateFileName,String CreateFileFormat) throws Exception{ File diretory = new File(&quot;&quot;); String currPath = diretory.getAbsolutePath(); String outputPath = currPath + &quot;\\output\\&quot;; String ffmpegPath = currPath + &quot;\\FFmpeg\\bin\\&quot;; if (!checkfile(sourcefile)) { System.out.println(sourcefile + &quot; is not file&quot;); } // 文件命名 //Calendar c = Calendar.getInstance(); List&lt;String&gt; commend = new ArrayList&lt;String&gt;(); commend.add(ffmpegPath+&quot;ffmpeg.exe&quot;); //commend.add(&quot;F:\\java\\TranscodeGUI\\ffmpeg.exe&quot;); commend.add(&quot;-i&quot;); commend.add(sourcefile); commend.add(&quot;-ab&quot;); commend.add(&quot;-vcodec&quot;); commend.add(&quot;h264&quot;); //commend.add(&quot;&quot;); commend.add(&quot;-b:v&quot;); commend.add(VideoBitrate); commend.add(&quot;-r&quot;); commend.add(&quot;25&quot;); commend.add(&quot;-s&quot;); commend.add(&quot;resolution&quot;); commend.add(&quot;-pix_fmt&quot;); commend.add(&quot;yuv420p&quot;); commend.add(&quot;-g&quot;); commend.add(&quot;33&quot;); commend.add(&quot;-acodec&quot;); commend.add(&quot;aac&quot;); commend.add(&quot;-b:a&quot;); commend.add(AudioBitrate); commend.add(&quot;-ac&quot;); commend.add(&quot;2&quot;); commend.add(&quot;-strict&quot;); commend.add(&quot;-2&quot;); commend.add(&quot;-f&quot;); commend.add(CreateFileFormat); commend.add(&quot;-y&quot;); commend.add(outputPath+CreateFileName+&quot;.&quot;+CreateFileFormat); try { ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); Process proc = builder.start(); InputStream stderr = proc.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line = null; while ( (line = br.readLine()) != null) System.out.println(line); int exitVal = proc.waitFor(); System.out.println(&quot;Process exitValue: &quot; + exitVal); } catch (Throwable t) { t.printStackTrace(); return false; } return true; } /* try { Runtime rt = Runtime.getRuntime(); ProcessBuilder builder = new ProcessBuilder(commend); builder.command(commend); builder.start(); System.out.println(&quot;开始转码，请等待······&quot;); } catch (Exception e) { e.printStackTrace(); System.out.println(&quot;转码异常，请查看日志！&quot;); } */ //检查文件是否存在 private static boolean checkfile(String path) { File file = new File(path); if (!file.isFile()) { return false; } return true; } }]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试的适用范围]]></title>
    <url>%2F2017%2F07%2F12%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[背景无 适用范围不适合自动化测试的情况1、定制型项目（一次性的）。 为客户定制的项目，维护期由客户方承担的，甚至采用的开发语言、运行环境也是客户特别要求的，即公司在这方面的测试积累就少，这样的项目不适合作自动化测试。 2、项目周期很短的项目。 项目周期很短，测试周期很短，就不值得花精力去投资自动化测试，好不容易建立起的测试脚本，不能得到重复的利用是不现实的。 3、业务规则复杂的对象。 业务规则复杂的对象，有很多的逻辑关系、运算关系，工具就很难测试。 4、美观、声音、易用性测试。 人的感观方面的：界面的美观、声音的体验、易用性的测试，也只有人来测试。 5、测试很少运行。 测试很少运行，对自动化测试就是一种浪费。自动化测试就是让它不厌其烦的、反反复复的运行才有效率。 6、软件不稳定。 软件不稳定，则会由于这些不稳定因素导致自动化测试失败。只有当软件达到相对的稳定，没有界面性严重错误和中断错误才能开始自动化测试。 7、涉及物理交互。 工具很难完成与物理设备的交互，比如刷卡的测试等。 适合自动化测试的情况自动化测试之所以能在很多大公司实施起来，就是有它适合自动化测试的特点和高的投资回报率。 1、产品型项目。 产品型的项目，每个项目只改进少量的功能，但每个项目必须反反复复的测试那些没有改动过的功能。这部分测试完全可以让自动化测试来承担， 同时可以把新加入的功能的测试也慢慢地加入到自动化测试当中。 2、增量式开发、持续集成项目。 由于这种开发模式是频繁的发布新版本进行测试，也就需要频繁的自动化测试，以便把人从中解脱出来测试新的功能。 3、能够自动编译、自动发布的系统。 要能够完全实现自动化测试，必须具有能够自动化编译，自动化发布系统进行测试的功能。 当然，不能达到这个要求也可以在手工干预的情况下进行自动化测试。 4、回归测试。 回归测试是自动化测试的强项，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。 5、多次重复、机械性动作，将烦琐的任务转化为自动化测试。 自动化测试最适用于多次重复、机械性动作，这样的测试对它来说从不会失败。比如要向系统输入大量的相似数据来测试压力和报表。 6、需要频繁运行测试。 在一个项目中需要频繁的运行测试，测试周期按天算，就能最大限度的利用测试脚本 总结考虑产品是否适合做自动化测试，比较普遍的共识是从三个方面进行权衡： 1、软件需求变动不频繁 2、项目周期较长 3、自动化测试脚本可重复使用]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ学习总结]]></title>
    <url>%2F2017%2F07%2F12%2Frabbitmq%2F</url>
    <content type="text"><![CDATA[什么是RabbitMQMessage Queue（MQ），消息队列是一种应用程序对应用程序的通信方法。应用程序通过读写MQ的消息（针对应用程序的数据）来通信，而无需建立专用连接来链接它们。MQ是消费者-生产模型的一个典型代表，一段不断写入消息，而另一段可以读取或者订阅队列中的消息。MQ是遵循AMQP协议的具体实现和产品。 适用场景RabbitMQ，或者说AMQP解决了什么问题，或者说它的应用场景是什么？ 对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： 1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？ 2）如何降低发送者和接收者的耦合度？ 3）如何让Priority高的接收者先接到数据？ 4）如何做到load balance？有效均衡接收者的负载？ 5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。 6）如何做到可扩展，甚至将这个通信模块发到cluster上？ 7）如何保证接收者接收到了完整，正确的数据？ AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 安装部署1、安装erlang 1）下载erlang源码，解压，进入$erlang目录，安装依赖包： yum install tk yum install tcl yum install unixODBC 2）编译erlang ./configure –prefix=/usr/local/erlang ./make ./make install 3）将erlang的bin目录添加至PATH 2、安装RabitMQ 1）下载RabbitMQ，解压至$RMQ 2）启动RabbitMQ ./bin/rabbitmq-server start 实际使用1、创建未完 相关博客链接：http://blog.csdn.net/column/details/rabbitmq.html]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium初学总结]]></title>
    <url>%2F2017%2F07%2F12%2FSelenium%E5%88%9D%E5%AD%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景工作中研究过一段时间自动化，因为一些原因暂时搁置了，以后会再捡起来，特记录一些selenium基本知识，供以后复习使用。 Selenium的简单介绍Selenium是什么Selenium是一款用于Web应用程序测试的工具，框架底层使用JavaScript模拟用户对浏览器进行操作。 selenium不是单纯的一个工具，是一组工具的集合，而且也有版本之分（目前3.0） selenium IDEselenium IDE 是嵌入到Firefox浏览器中的一个插件，实现简单的浏览器操作的录制与回放功能。 优点： 1、快速的创建bug重现脚本。 在测试过程中，发现了bug之后可以通过IDE将重现的步骤录制下来，可以帮助开发人员更容易的重现bug。 2、IDE录制的脚本可以转换成多种语言，有助于快速的开发脚本。 selenium GridSelenium Grid是一种自动化测试辅助工具，Grid通过利用现有的计算机基础设施，能加快Web-app的功能测试。利用Grid，可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例。 特点： 1、并行执行 2、通过一个主机统一控制用例在不同环境、不同浏览器下运行。 3、灵活添加变动测试机 selenium RCselenium RC是selenium的核心工具，selenium RC支持多种不同的语言编写自动化测试脚本，通过selenium RC的服务器作为代理服务器去访问应用从而达到测试的目的。 selenium RC分为Client Libraries和selenium Server两部分 Client Libraries: Client Libraries库主要用于编写测试脚本，是控制selenium Server的库。 Selenium Server: 负责控制浏览器行为，Selenium Server主要包括3个部分：Launcher、Http Proxy、Core。 Selenium Core：被Selenium Server嵌入到浏览器页面中的。Selenium Core其实就是一堆JS函数的集合，通过这些JS函数，才可以实现用程序对浏览器进行操作。 Launcher：用于启动浏览器，把selnium Core加载到浏览器页面当中，并把浏览器的代理设置为Selenium Server 的Http Proxy。 selenium 2.0selenium 2.0与selenium 1.0的关系，简单用公式表示为: selenium 2.0 = selenium 1.0 + WebDriver 在selenium 2.0中主推WebDriver，WebDriver是selenium RC的替代品，因为selenium为了向下兼容，所以selenium RC并没有被彻底抛弃，如果使用selenium开发一个新自动化测试项目，推荐使用WebDriver 。 selenium RC 与webdriver主要区别： selenium RC: 在浏览器中运行JavaScript应用，使用浏览器内置的JavaScript翻译器来翻译和执行selenese命令（selenese是selenium命令集合）。 WebDriver: 1、通过原生浏览器支持或者浏览器扩展直接控制浏览器 2、WebDriver针对各个浏览器而开发，取代了嵌入到被测Web应用中的JavaScript 3、与浏览器的紧密集成支持创建更高级的测试 4、避免了JavaScript安全模型导致的限制 5、利用操作系统级的调用模拟用户输入 Selenium的优势在哪对B/S应用支持很好 支持多平台/多浏览器 支持多语言开发(java、python、ruby、php、C#、JavaScript等) 支持分布式测试用例执行 学习内容丰富，增加测试工程师的技术竞争力 可选语言丰富 从语言易学性来讲，首选python和ruby 从语言应用广度来讲，首选java、C#和php等 从语言相关测试技术成度来讲：ruby、python和java 考虑整个技术团队主流用什么语言，然后选择相应的语言。 selenium集成java的一些常用方法1、页面元素定位方法: ID: driver.findElement(By.id(“ID值”)); Name: driver.findElement(By.name(“name值”)); 链接的全部文字: driver.findElement(By.linkText(“链接的全部文字内容”)); 部分链接文字: driver.findElement(By.partialLinkText(“链接的部分文字内容”)); Xpath: driver.findElement(By.xpath(“Xpath定位表达式”)); CSS: driver.findElement(By.cssSelector(“CSS定位表达式”)); Class: driver.findElement(By.className(“页面元素的Class属性值”)); 标签名称: driver.findElement(By.tagName (“页面元素的HTML标签名称”)); 2、打开浏览器: 打开firefox: WebDriver driver= new FirefoxDriver(); 打开ie: WebDriver driver =new InternetExplorerDriver(); 打开chrome: WebDriver driver = new ChromeDriver(); 打开指定路径浏览器: System.setProperty(&quot;webdriver.firefox.bin&quot;,&quot;D:\\ProgramFiles\\MozillaFirefox\\firefox.exe&quot;); 3、关闭浏览器: driver.close(); driver.quit(); 4、返回当前页面Title URL: driver.getTitle(); driver.getCurrentUrl(); 5、返回上一个访问的网页: driver.navigate().to(url1); driver.navigate().to(url2); driver.navigate().back(); 6、刷新当前网页: driver.navigate().refresh(); 7、输入框中输入指定内容: driver.sendKeys(); 8、输入框中清除文字内容: driver.clear(); 9、查看页面元素属性: driver.getAttribute(“value”); 10、点击按钮: driver.click(); 11、操作frame: Driver.switchTo.frame() 12、单选下拉列表: Select dropList = new Select(element); Select.getFrestSelectOption().getText(); Select.selectByIndex(); Select.selectByValue(); Select.selectByVisibleText(); 例子: 单选框: List&lt;WebElement&gt; radioList = driver.findElements(); radio. getAttribute(&quot;Value&quot;).equals(&quot;&quot;); radio.isSelectd() radio.click(); 复选框: List&lt;WebElement&gt; checkList = driver.findElements(); check.getAttribute(&quot;Value&quot;).equals(&quot;&quot;); check.isSelectd() check.click(); 13、Alert弹窗: Alert alert = driver.switchTo().alert(); alert.accept(); 14、执行JavaScript脚本： 声明一个JavaScript 执行器对象 JavaScriptExecutor js = (JavaScriptExecutor )driver; js.executeScript(“loginSubmit();”); 总结无]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>自动化测试</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmon使用总结]]></title>
    <url>%2F2017%2F07%2F12%2Fnmon%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、安装： 1、下载nmon，wget http://sourceforge.net/projects/nmon/files/nmon_linux_14i.tar.gz 2、拷贝到服务器上，scp nmon_linux_14i.tar.gz root@10.171.112.220:/home 3、解压 4、根据服务器操作系统，执行相关命令二、使用方法： 监控系统性能参数生成监控文件： nmon -f -s 2 -c 300 （每隔2秒采集一次性能参数，总共采集300次，即10分钟） 注意：nmon analyser打开监控文件报错误‘13’:类型不匹配，的解决办法，更改系统日期格式为“yyyy-mm-dd”]]></content>
      <categories>
        <category>性能工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>Nmon</tag>
        <tag>监控工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库模型的简单理解]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景公司针对mysql和mongo开发了相应的数据库管理平台（其实就是包了个壳），需对底层数据库做性能测试，获取相应的性能参数，在此记录测试过程中学到的一些东西 什么是数据模型？访问数据库中的数据取决于数据库实现的数据模型。 数据模型会影响客户端通过API对数据的操作。不同的数据模型可能会提供或多或少的功能。一般而言，数据模型不会直接提供过多的功能，许多功能必须由客户端自行实现。 数据模型决定了客户端如何对数据进行编码存储。应用程序需要某种域模型与存储技术支持的特性进行映射。 有哪些数据库模型关系模型关系模型使用记录（由元组组成）进行存储，记录存储在表中，表由架构界定。 表中的每个列都有名称和类型，表中的所有记录都要符合表的定义。 SQL是专门的查询语言，提供相应的语法查找符合条件的记录，如表联接（Join）。表联接可以基于表之间的关系在多表之间查询记录。 表中的记录可以被创建和删除，记录中的字段也可以单独更新。 关系模型数据库通常提供事务处理机制，这为涉及多条记录的自动化处理提供了解决方案。 对不同的编程语言而言，表可以被看成数组、记录列表或者结构。表可以使用B树和哈希表进行索引，以应对高性能访问。 键值存储键值存储提供了基于键对值的访问方式。 键值对可以被创建或删除，与键相关联的值可以被更新。 键值存储一般不提供事务处理机制。 对不同的编程语言而言，键值存储类似于哈希表。对此，不同的编程语言有不同的名字（如，Java称之为“HashMap”，Perl称之为“hash”，Python称之为“dict”，PHP称之为“associative array”），C++则称之为“boost::unordered_map&lt;...&gt;”。 键值存储支持键上自有的隐式索引。 键值存储看起来好像不太有用，但却可以在“值”上存储大量信息。“值”可以是一个XML文档，一个JSON对象，或者其它任何序列化形式。 重要的是，键值存储引擎并不在意“值”的内部结构，它依赖客户端对“值”进行解释和管理。 文档存储文档存储支持对结构化数据的访问，不同于关系模型的是，文档存储没有强制的架构。 事实上，文档存储以封包键值对的方式进行存储。在这种情况下，应用对要检索的封包采取一些约定，或者利用存储引擎的能力将不同的文档划分成不同的集合，以管理数据。 与关系模型不同的是，文档存储模型支持嵌套结构。例如，文档存储模型支持XML和JSON文档，字段的“值”又可以嵌套存储其它文档。文档存储模型也支持数组和列值键。 与键值存储不同的是，文档存储关心文档的内部结构。这使得存储引擎可以直接支持二级索引，从而允许对任意字段进行高效查询。支持文档嵌套存储的能力，使得查询语言具有搜索嵌套对象的能力，XQuery就是一个例子。 MongoDB通过支持在查询中指定JSON字段路径实现类似的功能。 列式存储如果翻转数据，列式存储与关系存储将会非常相似。 与关系模型存储记录不同，列式存储以流的方式在列中存储所有的数据。对于任何记录，索引都可以快速地获取列上的数据。 Map-reduce的实现Hadoop的流数据处理效率非常高，列式存储的优点体现的淋漓极致。因此，HBase和Hypertable通常作为非关系型数据仓库，为Map-reduce进行数据分析提供支持。 关系类型的列标对数据分析效果不好，因此，用户经常将更复杂的数据存储在列式数据库中。这直接体现在Cassandra中，它引入的“column family”可以被认为是一个“super-column”。 列式存储支持行检索，但这需要从每个列获取匹配的列值，并重新组成行。 图形数据库图形数据库存储顶点和边的信息，有的支持添加注释。 图形数据库可用于对事物建模，如社交图谱、真实世界的各种对象。IMDB（Internet Movie Database）站点的内容就组成了一幅复杂的图像，演员与电影彼此交织在一起。 图形数据库的查询语言一般用于查找图形中断点的路径，或端点之间路径的属性。 Neo4j是一个典型的图形数据库。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库性能的影响因素]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[背景公司针对mysql和mongo开发了相应的数据库管理平台（其实就是包了个壳），需对底层数据库做性能测试，获取相应的性能参数，在此记录测试过程中学到的一些东西 影响数据库性能表现的因素简单概括，通常会有如下相关项： 硬件、操作系统、数据库配置、应用模型 1、硬件 1）变化的硬件： 通常指裸机配置等，如CPU、内存大小都对性能有重要影响。 再如裸设备、固态硬盘等，对性能也影响很大。 2）变化的网络环境： 10M、100M、千兆以太网甚至光纤等，会对应用系统的整体性能产生较大影响。 2、操作系统 典型的如Linux系列、Win系列，通常会有不同的性能表现。 操作系统的一些设置，也可能对数据库性能造成影响。比如块读写的设置等。 3、数据库 数据库，至少包含2部分内容，一是数据库引擎，一是接口（如JDBC、ODBC等）。 1）接口如果实现的不好，某些时候，也容易成为瓶颈。 2）数据库引擎，可调优之处很多，需要根据实际情况，综合判断。如分区、索引、日志、数据文件、数据库可调参数等 4、应用模型 基于数据库的应用，原型是什么样的，需要深入了解，掌握，才能因地制宜地结合数据库一起调优。 目前国内对于数据库的应用现状，基本的问题是：应用不当，SQL写法有误。 应用模型对于数据库的影响可能有： 1）读多写少、读写并重、读少写多； 2）并发情况 3）数据量 4）中间件 总之，应用逻辑和应用模型对数据库的使用方式，更多地影响着系统的瓶颈（通常情况，硬件一旦固定，更换的机会少。比如，数据库性能测试的TPCX系列，很多硬件厂家给出的测试最佳值，都是在固定硬件的环境下进行的）。 附：什么是数据库应用模型？参考本博客：《数据库应用模型的简单理解》]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[st-load安装与使用]]></title>
    <url>%2F2017%2F07%2F11%2Fsrs-bench%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目需要，需对onsite直播服务器做性能测试，尝试了Jmeter，LoadRunner后选择了st-load。 什么是st-load服务器负载测试工具(st-load)：st-load使用nginx-rtmp的协议直接将chunk流解析为messgae。state-threads用来模拟超级并发，并简化异步socket的逻辑为同步socket，http-parser解析http协议部分。这两个库设计都很巧妙，参考大牛开的项目：https://github.com/ossrs/srs-benchstate-threads之前就有写过文章说明，那时候主要是支持高并发的rtmp服务器，也是并发和异步变为同步的协程很方便。http-parser用yum就可以search到，它其实设计得也相当巧妙，相当于只是解析buffer的http内容，并不负责网络部分。而libcurl/poco等都带了网络处理，所以不合适。举例说明，http_parser_parse_url这个函数，解析url，设计得非常有意思，不是返回字符串，而是返回位置索引，譬如主机头在什么位置长度多长等等。 模拟huge并发：2G内存就可以开300k连接。基于states-threads的协程。 支持HLS解析和测试，下载ts片后等待一个切片长度，模拟客户端。支持HLS点播和直播。 支持HTTP负载测试，所有并发重复下载一个http文件。可将80Gbps带宽测试的72Gbps。 支持RTMP流播放测试，一个进程支持5k并发。 支持RTMP流推流测试，一个进程支持500个并发 RTMP协议使用高性能服务器SRS(SimpleRtmpServer)的协议栈。 注意：HTTP/HLS：依赖服务器Content-Length，不支持chunked方式(chunked时会把所有内容当做body一直读)。所有程序都在Linux下运行，模拟客户端运行。其他工具参考srs-librtmp 安装配置安装前需下载安装依赖软件包，使用git下载最新版本的srs-bench源码包 [root@cdvcloud huangyl]# yum install git unzip patch gcc gcc-c++ make [root@cdvcloud huangyl]# git clone https://github.com/simple-rtmp-server/srs-bench.git 编译 [root@cdvcloud srs-bench-master]# ./configure [root@cdvcloud srs-bench-master]# make 查看生成的文件和目录 [root@cdvcloud objs]# ls http-parser-2.1 sb_hls_load sb_rtmp_load sb_rtmp_publish st-1.9 Makefile sb_http_load sb_rtmp_load_fast src 使用方法模拟RTMP播放用户 ./objs/sb_rtmp_load_fast -c 1000 -r rtmp://192.168.0.104/na84qi/dgarfm 模拟HLS直播用户 ./objs/sb_hls_load -c 1 -r http://192.168.0.104/na84qi/dgarfm.m3u8 模拟HSL点播用户 ./objs/st_hls_load -c 1 -o -r http://192.168.0.104/na84qi/dgarfm.m3u8 模拟RTMP推流用户 ./objs/sb_rtmp_publish -i out_time.mp4 -c 1 -r rtmp://192.168.0.103/x1m4eu/16vpuy 模拟RTMP多路推流用户 ./sb_rtmp_publish -i out_time.mp4 -c 1000 -r rtmp://192.168.0.103/live/livestream_{i} example: start a client ./objs/sb_rtmp_load_fast -c 1 -r rtmp://127.0.0.1:1935/live/livestream start 1000 clients ./objs/sb_rtmp_load_fast -c 1000 -r rtmp://127.0.0.1:1935/live/livestream start 10000 clients ./objs/sb_rtmp_load_fast -c 10000 -r rtmp://127.0.0.1:1935/live/livestream start 100000 clients ./objs/sb_rtmp_load_fast -c 100000 -r rtmp://127.0.0.1:1935/live/livestream 参考： http://blog.csdn.net/win_lin/article/details/11835011 http://blog.csdn.net/xiaojun111111/article/details/52102454 http://blog.csdn.net/heiyeshuwu/article/details/52316738 https://github.com/ossrs/srs-bench]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>st-load</tag>
        <tag>直播流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试页]]></title>
    <url>%2F2017%2F07%2F11%2F%E6%B5%8B%E8%AF%95%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[此篇文章测试使用！]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>