<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[11款常用的web应用框架]]></title>
    <url>%2F2017%2F08%2F10%2F%E5%87%A0%E6%AC%BE%E5%B8%B8%E7%94%A8%E7%9A%84web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[几款常用的web应用框架 Rails 代码托管地址：https://github.com/rails/rails Express 代码托管地址：https://github.com/rails/rails Django 代码托管地址：https://github.com/django/django Meteor 代码托管地址：https://github.com/meteor/meteor CakePHP 代码托管地址：https://github.com/cakephp/cakephp Symfony 代码托管地址：https://github.com/symfony/symfony Sinatra 代码托管地址：https://github.com/sinatra/sinatra Flask 代码托管地址：https://github.com/mitsuhiko/flask Laravel 代码托管地址：https://github.com/laravel/laravel Sails 代码托管地址：https://github.com/balderdashy/sails Revel 代码托管地址：https://github.com/revel/revel 参考文档：https://yusi123.com/3654.html]]></content>
      <categories>
        <category>博</category>
      </categories>
      <tags>
        <tag>web应用框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下expect脚本语言的简单使用]]></title>
    <url>%2F2017%2F07%2F24%2FExpect%E4%BA%A4%E4%BA%92%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景最近在做直播服务器性能测试，因单台推流服务器性能限制，需多台机器同时推流，而且要监控直播平台各个底层服务器的性能，手动推流并开启监控繁琐而且易出错，故有如下内容。 什么是Expect介绍Expect是一个用来实现自动交互功能的软件套件。使用它，系统管理员可以创建脚本来对命令或程序进行输入，而这些命令和程序是期望从终端（terminal）得到输入，一般来说这些输入都需要手工输入进行的。Expect则可以根据程序的提示模拟标准输入提供给程序需要的输入来实现交互程序执行。甚至可以实现简单的BBS聊天机器人。 Expect是不断发展的，随着时间的流逝，其功能越来越强大，已经成为系统管理员的的一个强大助手。Expect需要Tcl编程语言的支持，要在系统上运行Expect必须首先安装Tcl。 Expect的四个关键命令：spawn：启动新的进程 expect：从进程接收字符串 send：用于向进程发送字符串 interact：允许用户交互 安装直接使用yum安装相关依赖库以及expect yum install tcl yum install expect 使用pushtestall.sh远程登录启动nmon监控和ffmpeg推流脚本 #!/usr/bin/expect -f set password CDVcloud123 set listnmon /home/huangyl/nmon set listffmpeg /home/huangyl set script loop.sh set timeout -1 #外网登录推流1 spawn ssh root@101.201.237.216 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } #登录入口1,并开启nmon监控 spawn ssh root@172.18.1.14 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录入口2，并开启nmon监控 spawn ssh root@172.18.29.128 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录出口1，并开启nmon监控 spawn ssh root@172.18.29.124 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录出口2，并开启nmon监控 spawn ssh root@172.18.1.15 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口1，并开启nmon监控 spawn ssh root@172.18.1.17 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口2，并开启nmon监控 spawn ssh root@172.18.29.125 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录直播1，并开启nmon监控 spawn ssh root@172.18.1.16 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录直播2，并开启nmon监控 spawn ssh root@172.18.29.127 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录推流1，执行推流命令 spawn ssh root@172.18.1.6 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #登录推流2，执行推流命令 spawn ssh root@172.18.1.9 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #登录推流2，执行推流命令 spawn ssh root@172.18.1.18 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #控制权移交 interact killffmpeg.sh#!/usr/bin/expect -f set password CDVcloud123 #set listnmon /home/huangyl/nmon set listffmpeg /home/huangyl set timeout -1 #外网登录推流1，并杀死ffmpeg spawn ssh root@101.201.237.216 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #内网登录推流2，并杀死ffmpeg spawn ssh root@172.18.1.9 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #内网登录推流3，并杀死ffmpeg spawn ssh root@172.18.1.18 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #控制权移交 interact playtest.shsrs_bench压测 #!/usr/bin/expect -f set password CDVcloud123 set listnmon /home/huangyl/nmon set listbench /home/huangyl/srs-bench-master/objs set usernum 1 set roadname https://zbfee.cdvcloud.com/551016/551016/7t3dmx/g96gwq/06ijj2.m3u8 #set script loop.sh set timeout 30 #登录出口1，打开nmon监控 spawn ssh root@172.18.29.124 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录出口2，打开nmon监控 spawn ssh root@172.18.1.15 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口1，打开nmon监控 spawn ssh root@172.18.1.17 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录接口2，打开nmon监控 spawn ssh root@172.18.29.125 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录srs_bench，开始模拟直播观看 spawn ssh root@172.18.1.6 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listbench\r&quot; expect &quot;*#&quot; send &quot;./sb_hls_load -c $usernum -r $roadname\r&quot; #控制权移交 interact 以上，深深的感受到自动化脚本语言的强大~]]></content>
      <categories>
        <category>Expect</category>
      </categories>
      <tags>
        <tag>Expect</tag>
        <tag>性能测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理修改DNS]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%89%B9%E5%A4%84%E7%90%86%E4%BF%AE%E6%94%B9DNS%2F</url>
    <content type="text"><![CDATA[工作中经常要登录线上环境和内网测试环境，手动修改DNS甚是麻烦，特写下如下命令，顺带简单学习下批处理命令： @echo off cls echo 请选择DNS设置为内网（y）or外网（n）： set /p name= if &quot;%name%&quot;==&quot;y&quot; goto Ys if &quot;%name%&quot;==&quot;n&quot; goto No :Ys echo.正在修改dns··· netsh interface ip set dns &quot;本地连接&quot; static 192.168.0.88 primary echo 已设置为192.168.0.88 &gt;nul&amp;&amp;exit :No echo.正在修改dns··· netsh interface ip set dns name=&quot;本地连接&quot; source=dhcp echo 已设置为自动获取DNS &gt;nul&amp;&amp;exit]]></content>
      <categories>
        <category>批处理</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于ffmpeg进行转码工具的编写（未完成）]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%9F%BA%E4%BA%8Effmpeg%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考了一些资料，学习过程中尝试写一个转码工具，由于一些个人能力和其他的一些原因暂时搁置，特此记录一些代码，留作参考。 一、GUI： package cn.com.huangyl.tool; import java.awt.BorderLayout; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.Calendar; import java.util.List; import javax.swing.DefaultComboBoxModel; import javax.swing.JButton; import javax.swing.JComboBox; import javax.swing.JFileChooser; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTabbedPane; import javax.swing.JTextArea; import javax.swing.JTextField; public class FFmpegGUI { private JFrame frame = new JFrame(&quot;FFmpegGUI&quot;); private JTabbedPane tabbedPane = new JTabbedPane(); private JPanel panel1 = new JPanel(new BorderLayout()); private JPanel panelx = new JPanel(new BorderLayout()); private JPanel panely = new JPanel(new BorderLayout()); private JPanel panel2 = new JPanel(new BorderLayout()); private JPanel panel3 = new JPanel(new GridLayout(2, 1)); private JPanel panel4 = new JPanel(new BorderLayout()); private JPanel panel5 = new JPanel(new BorderLayout()); private JPanel panel6 = new JPanel(new BorderLayout()); private JPanel panel7 = new JPanel(new BorderLayout()); private JPanel panel8 = new JPanel(new BorderLayout()); private JPanel panel9 = new JPanel(new BorderLayout()); private JPanel panel10 = new JPanel(new BorderLayout()); private JPanel panel11 = new JPanel(new BorderLayout()); private JPanel panel12 = new JPanel(new GridLayout(6,1)); private JPanel panel13 = new JPanel(new GridLayout(6,1)); private JPanel panel14 = new JPanel(new BorderLayout()); private JPanel panel15 = new JPanel(new BorderLayout()); private JPanel panel16 = new JPanel(new BorderLayout()); private JPanel panel17 = new JPanel(new BorderLayout()); private JPanel panel18 = new JPanel(new GridLayout(1,2)); private JPanel panel19 = new JPanel(new BorderLayout()); private JPanel panel20 = new JPanel(new BorderLayout()); private JButton Select = new JButton(&quot;选择&quot;); private JButton StartTranscode = new JButton(&quot;开始&quot;); private JButton Reset = new JButton(&quot;重置&quot;); //private JTextField display = new JTextField(&quot;请点击查询按钮&quot;); private JTextField FilePath = new JTextField(&quot;请选择文件路径&quot;); private JTextField VideoBitrate = new JTextField(); private JTextField resolution = new JTextField(); private JTextField AudioBitrate = new JTextField(); private JTextField AudioSampleRate = new JTextField(); private JTextField CreateFileName = new JTextField(); private JTextField CreateFileFormat = new JTextField(); private JLabel label1 = new JLabel(&quot;请选择文件&quot;); private JLabel label2 = new JLabel(&quot;模板转码&quot;); private JLabel label3 = new JLabel(&quot;请选择模板：&quot;); private JLabel label4 = new JLabel(&quot;自由转码&quot;); private JLabel label5 = new JLabel(&quot;视频码率：&quot;); private JLabel label6 = new JLabel(&quot;分辨率：&quot;); private JLabel label7 = new JLabel(&quot;音频码率：&quot;); private JLabel label8 = new JLabel(&quot;音频采样率：&quot;); private JLabel label9 = new JLabel(&quot;请选择转码方式：&quot;); private JLabel label10 = new JLabel(&quot;留做进度条：&quot;); private JLabel label11 = new JLabel(&quot;生成文件名称：&quot;); private JLabel label12 = new JLabel(&quot;生成文件格式：&quot;); private JComboBox Template = new JComboBox(); private JComboBox TranscodeWay = new JComboBox(); private JTextArea Log = new JTextArea(&quot;&quot;); private JScrollPane scrollPane1 = new JScrollPane(); private JFileChooser stf = new JFileChooser(new File(&quot;d://&quot;)); FFmpegGUI(){ frame.setLayout(null); frame.setBounds(400, 200, 700, 420); frame.setVisible(true); frame.setDefaultCloseOperation(3); tabbedPane.addTab(&quot;ffmpeg&quot;, this.panel1); tabbedPane.addTab(&quot;ffplay&quot;, this.panelx); tabbedPane.addTab(&quot;ffprobe&quot;, this.panely); tabbedPane.setBounds(10, 10, 660, 360); frame.add(this.tabbedPane); panel1.add(&quot;West&quot;,panel2); panel1.add(&quot;Center&quot;,panel19); panel19.add(&quot;Center&quot;,Log); panel19.add(&quot;South&quot;,label10); panel2.add(&quot;North&quot;,panel3); panel2.add(&quot;Center&quot;,panel8); panel3.add(panel4); panel3.add(panel5); panel4.add(&quot;North&quot;,label1); panel4.add(&quot;South&quot;,panel6); panel5.add(&quot;North&quot;,label2); panel5.add(&quot;South&quot;,panel7); panel6.add(&quot;Center&quot;,FilePath); panel6.add(&quot;East&quot;,Select); Template.setModel(new DefaultComboBoxModel(new String[] { &quot;1080p_1920x1080_2000&quot;, &quot;SHD_1280x720_1200&quot;, &quot;HD_960x540_800&quot;, &quot;SD_640x360_500&quot;, &quot;LD_360x240_300&quot;,&quot;...&quot; })); Template.setEditable(false); panel7.add(&quot;Center&quot;,Template); panel7.add(&quot;West&quot;,label3); panel8.add(&quot;North&quot;,label4); panel8.add(&quot;Center&quot;,panel9); panel9.add(&quot;North&quot;,panel10); panel9.add(&quot;Center&quot;,panel11); panel10.add(&quot;West&quot;,panel12); panel10.add(&quot;Center&quot;,panel13); panel12.add(label5); panel12.add(label6); panel12.add(label7); panel12.add(label8); panel12.add(label11); panel12.add(label12); panel13.add(VideoBitrate); panel13.add(resolution); panel13.add(AudioBitrate); panel13.add(AudioSampleRate); panel13.add(CreateFileName); panel13.add(CreateFileFormat); panel11.add(&quot;North&quot;,panel14); panel11.add(&quot;Center&quot;,panel15); TranscodeWay.setModel(new DefaultComboBoxModel(new String[] { &quot;模板转码&quot;, &quot;自由转码&quot; })); TranscodeWay.setEditable(false); panel14.add(&quot;West&quot;,label9); panel14.add(&quot;Center&quot;,TranscodeWay); panel15.add(&quot;Center&quot;,panel16); panel15.add(&quot;South&quot;,panel17); panel17.add(&quot;East&quot;,panel18); panel18.add(Reset); panel18.add(StartTranscode); //文件选择 this.Select.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent event){ FFmpegGUI.this.stf.setFileSelectionMode(0); int state = FFmpegGUI.this.stf.showOpenDialog(null); if(state == 1){ return; } File f = FFmpegGUI.this.stf.getSelectedFile(); FFmpegGUI.this.FilePath.setText(f.getAbsolutePath()); } }); this.StartTranscode.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { String transcodeway = FFmpegGUI.this.TranscodeWay.getSelectedItem().toString(); if (&quot;模板转码&quot;.equals(transcodeway)) { String sourcefile = FFmpegGUI.this.FilePath.getText(); String Template = FFmpegGUI.this.TranscodeWay.getSelectedItem().toString(); FFmpegGUI.this.Log.setText(sourcefile); Transcode t = new Transcode(); } if (&quot;自由转码&quot;.equals(transcodeway)){ String sourcefile = FFmpegGUI.this.FilePath.getText(); String VideoBitrate = FFmpegGUI.this.VideoBitrate.getText(); String resolution = FFmpegGUI.this.resolution.getText(); String AudioBitrate = FFmpegGUI.this.AudioBitrate.getText(); String AudioSampleRate = FFmpegGUI.this.AudioSampleRate.getText(); String CreateFileName = FFmpegGUI.this.CreateFileName.getText(); String CreateFileFormat = FFmpegGUI.this.CreateFileFormat.getText(); Transcode t = new Transcode(); try { t.processTranscodefree(sourcefile,VideoBitrate,resolution,AudioBitrate,AudioSampleRate,CreateFileName,CreateFileFormat); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }); } public static void main(String args[]){ new FFmpegGUI(); } } 二、Transcode package cn.com.huangyl.tool; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class Transcode { /* private static int checkContentType(){ String type = sourcefile.substring(PATH.lastIndexOf(&quot;.&quot;) + 1, sourcefile.length()) .toLowerCase(); //ffmpeg能解析的格式:(asx，asf，mpg，wmv，3gp，mp4，mov，avi，flv等) if (type.equals(&quot;avi&quot;)) { return 0; } else if (type.equals(&quot;mpg&quot;)) { return 0; } else if (type.equals(&quot;wmv&quot;)) { return 0; } else if (type.equals(&quot;3gp&quot;)) { return 0; } else if (type.equals(&quot;mov&quot;)) { return 0; } else if (type.equals(&quot;mp4&quot;)) { return 0; } else if (type.equals(&quot;asf&quot;)) { return 0; } else if (type.equals(&quot;asx&quot;)) { return 0; } else if (type.equals(&quot;flv&quot;)) { return 0; } //对ffmpeg无法解析的文件格式(wmv9，rm，rmvb等),可以先用别的工具（mencoder）转换为avi(ffmpeg能解析的)格式. else if (type.equals(&quot;wmv9&quot;)) { return 1; } else if (type.equals(&quot;rm&quot;)) { return 1; } else if (type.equals(&quot;rmvb&quot;)) { return 1; } return 9; } // 对ffmpeg无法解析的文件格式(wmv9，rm，rmvb等), 可以先用别的工具（mencoder）转换为avi(ffmpeg能解析的)格式. private static String processAVI(int type) { List&lt;String&gt; commend = new ArrayList&lt;String&gt;(); commend.add(&quot;c:\\ffmpeg\\mencoder&quot;); commend.add(sourcefile); commend.add(&quot;-oac&quot;); commend.add(&quot;lavc&quot;); commend.add(&quot;-lavcopts&quot;); commend.add(&quot;acodec=mp3:abitrate=64&quot;); commend.add(&quot;-ovc&quot;); commend.add(&quot;xvid&quot;); commend.add(&quot;-xvidencopts&quot;); commend.add(&quot;bitrate=600&quot;); commend.add(&quot;-of&quot;); commend.add(&quot;avi&quot;); commend.add(&quot;-o&quot;); commend.add(&quot;c:\\ffmpeg\\output\\a.avi&quot;); try { ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); builder.start(); return &quot;c:\\ffmpeg\\output\\a.avi&quot;; } catch (Exception e) { e.printStackTrace(); return null; } } public void processTranscodetemp(String Template,String sourcefile) throws Exception { String type = sourcefile.substring(sourcefile.lastIndexOf(&quot;.&quot;) + 1, sourcefile.length()) .toLowerCase(); String F1080p_1920x1080_2000 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 2000k -r 25 -s 1920x1080 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;1080P_2M.&quot;+type; String SHD_1280x720_1200 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 1200k -r 25 -s 1280x720 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;720P_1200.&quot;+type; String HD_960x540_800 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 800k -r 25 -s 960x540 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;540P_800.&quot;+type; String SD_640x360_500 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 500k -r 25 -s 640x360 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;360P_500.&quot;+type; String LD_360x240_300 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 300k -r 25 -s 360x240 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;240P_500.&quot;+type; if (!checkfile(sourcefile)) { System.out.println(sourcefile + &quot; is not file&quot;); } try{ Runtime rt = Runtime.getRuntime(); Process proc; proc = rt.exec(F1080p_1920x1080_2000); // 取得命令结果的输出流 InputStream fis = proc.getInputStream(); // 用一个读输出流类去读 InputStreamReader isr = new InputStreamReader(fis); // 用缓冲器读行 BufferedReader br = new BufferedReader(isr); String line = null; // 直到读完为止 while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } */ public boolean processTranscodefree(String sourcefile,String VideoBitrate,String resolution,String AudioBitrate,String AudioSampleRate,String CreateFileName,String CreateFileFormat) throws Exception{ File diretory = new File(&quot;&quot;); String currPath = diretory.getAbsolutePath(); String outputPath = currPath + &quot;\\output\\&quot;; String ffmpegPath = currPath + &quot;\\FFmpeg\\bin\\&quot;; if (!checkfile(sourcefile)) { System.out.println(sourcefile + &quot; is not file&quot;); } // 文件命名 //Calendar c = Calendar.getInstance(); List&lt;String&gt; commend = new ArrayList&lt;String&gt;(); commend.add(ffmpegPath+&quot;ffmpeg.exe&quot;); //commend.add(&quot;F:\\java\\TranscodeGUI\\ffmpeg.exe&quot;); commend.add(&quot;-i&quot;); commend.add(sourcefile); commend.add(&quot;-ab&quot;); commend.add(&quot;-vcodec&quot;); commend.add(&quot;h264&quot;); //commend.add(&quot;&quot;); commend.add(&quot;-b:v&quot;); commend.add(VideoBitrate); commend.add(&quot;-r&quot;); commend.add(&quot;25&quot;); commend.add(&quot;-s&quot;); commend.add(&quot;resolution&quot;); commend.add(&quot;-pix_fmt&quot;); commend.add(&quot;yuv420p&quot;); commend.add(&quot;-g&quot;); commend.add(&quot;33&quot;); commend.add(&quot;-acodec&quot;); commend.add(&quot;aac&quot;); commend.add(&quot;-b:a&quot;); commend.add(AudioBitrate); commend.add(&quot;-ac&quot;); commend.add(&quot;2&quot;); commend.add(&quot;-strict&quot;); commend.add(&quot;-2&quot;); commend.add(&quot;-f&quot;); commend.add(CreateFileFormat); commend.add(&quot;-y&quot;); commend.add(outputPath+CreateFileName+&quot;.&quot;+CreateFileFormat); try { ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); Process proc = builder.start(); InputStream stderr = proc.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line = null; while ( (line = br.readLine()) != null) System.out.println(line); int exitVal = proc.waitFor(); System.out.println(&quot;Process exitValue: &quot; + exitVal); } catch (Throwable t) { t.printStackTrace(); return false; } return true; } /* try { Runtime rt = Runtime.getRuntime(); ProcessBuilder builder = new ProcessBuilder(commend); builder.command(commend); builder.start(); System.out.println(&quot;开始转码，请等待······&quot;); } catch (Exception e) { e.printStackTrace(); System.out.println(&quot;转码异常，请查看日志！&quot;); } */ //检查文件是否存在 private static boolean checkfile(String path) { File file = new File(path); if (!file.isFile()) { return false; } return true; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试的适用范围]]></title>
    <url>%2F2017%2F07%2F12%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[什么情况适用自动化测试 什么情况不适用自动化测试 一、不适合自动化测试的情况 • 定制型项目（一次性的）。为客户定制的项目，维护期由客户方承担的，甚至采用的开发语言、运行环境也是客户特别要求的，即公司在这方面的测试积累就少，这样的项目不适合作自动化测试。 • 项目周期很短的项目。项目周期很短，测试周期很短，就不值得花精力去投资自动化测试，好不容易建立起的测试脚本，不能得到重复的利用是不现实的。 • 业务规则复杂的对象。业务规则复杂的对象，有很多的逻辑关系、运算关系，工具就很难测试。 • 美观、声音、易用性测试。人的感观方面的：界面的美观、声音的体验、易用性的测试，也只有人来测试。 • 测试很少运行。测试很少运行，对自动化测试就是一种浪费。自动化测试就是让它不厌其烦的、反反复复的运行才有效率。 • 软件不稳定。软件不稳定，则会由于这些不稳定因素导致自动化测试失败。只有当软件达到相对的稳定，没有界面性严重错误和中断错误才能开始自动化测试。 • 涉及物理交互。工具很难完成与物理设备的交互，比如刷卡的测试等。 二、适合自动化测试的情况 自动化测试之所以能在很多大公司实施起来，就是有它适合自动化测试的特点和高的投资回报率。 • 产品型项目。产品型的项目，每个项目只改进少量的功能，但每个项目必须反反复复的测试那些没有改动过的功能。这部分测试完全可以让自动化测试来承担， 同时可以把新加入的功能的测试也慢慢地加入到自动化测试当中。 • 增量式开发、持续集成项目。由于这种开发模式是频繁的发布新版本进行测试，也就需要频繁的自动化测试，以便把人从中解脱出来测试新的功能。 • 能够自动编译、自动发布的系统。要能够完全实现自动化测试，必须具有能够自动化编译，自动化发布系统进行测试的功能。 当然，不能达到这个要求也可以在手工干预的情况下进行自动化测试。 • 回归测试。回归测试是自动化测试的强项，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。 • 多次重复、机械性动作，将烦琐的任务转化为自动化测试。自动化测试最适用于多次重复、机械性动作，这样的测试对它来说从不会失败。比如要向系统输入大量的相似数据来测试压力和报表。 • 需要频繁运行测试。在一个项目中需要频繁的运行测试，测试周期按天算，就能最大限度的利用测试脚本]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ初接触]]></title>
    <url>%2F2017%2F07%2F12%2Frabbitmq%2F</url>
    <content type="text"><![CDATA[什么是RabbitMQMessage Queue（MQ），消息队列是一种应用程序对应用程序的通信方法。应用程序通过读写MQ的消息（针对应用程序的数据）来通信，而无需建立专用连接来链接它们。MQ是消费者-生产模型的一个典型代表，一段不断写入消息，而另一段可以读取或者订阅队列中的消息。MQ是遵循AMQP协议的具体实现和产品。 适用场景RabbitMQ，或者说AMQP解决了什么问题，或者说它的应用场景是什么？ 对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： 1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？ 2）如何降低发送者和接收者的耦合度？ 3）如何让Priority高的接收者先接到数据？ 4）如何做到load balance？有效均衡接收者的负载？ 5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。 6）如何做到可扩展，甚至将这个通信模块发到cluster上？ 7）如何保证接收者接收到了完整，正确的数据？ AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 安装部署1、安装erlang 1）下载erlang源码，解压，进入$erlang目录，安装依赖包： yum install tk yum install tcl yum install unixODBC 2）编译erlang ./configure –prefix=/usr/local/erlang ./make ./make install 3）将erlang的bin目录添加至PATH 2、安装RabitMQ 1）下载RabbitMQ，解压至$RMQ 2）启动RabbitMQ ./bin/rabbitmq-server start 实际使用1、创建未完 相关博客链接：http://blog.csdn.net/column/details/rabbitmq.html]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
        <tag>java</tag>
        <tag>web自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium初学总结]]></title>
    <url>%2F2017%2F07%2F12%2FSelenium%E5%88%9D%E5%AD%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[工作中研究过一段时间自动化，因为一些原因暂时搁置了，以后会再捡起来，特记录一些selenium基本知识，供以后复习使用。 selenium集成java的一些常用方法： 1、页面元素定位方法：ID: driver.findElement(By.id(“ID值”));Name: driver.findElement(By.name(“name值”));链接的全部文字 : driver.findElement(By.linkText(“链接的全部文字内容”));部分链接文字: driver.findElement(By.partialLinkText(“链接的部分文字内容”));Xpath : driver.findElement(By.xpath(“Xpath定位表达式”));CSS: driver.findElement(By.cssSelector(“CSS定位表达式”));Class: driver.findElement(By.className(“页面元素的Class属性值”));标签名称:driver.findElement(By.tagName (“页面元素的HTML标签名称”)); 2、打开浏览器：打开firefox ： WebDriver driver= new FirefoxDriver();打开ie ：WebDriver driver =new InternetExplorerDriver();打开chrome： WebDriver driver = new ChromeDriver();打开指定路径浏览器 ： System.setProperty(“webdriver.firefox.bin”,”D:\ProgramFiles\MozillaFirefox\firefox.exe”); 3、关闭浏览器：driver.close();driver.quit(); 4、返回当前页面Title URLdriver.getTitle();driver.getCurrentUrl(); 5、返回上一个访问的网页driver.navigate().to(url1);driver.navigate().to(url2);driver.navigate().back();6、刷新当前网页：driver.navigate().refresh();7、输入框中输入指定内容:driver.sendKeys();8、输入框中清除文字内容：driver.clear();9、查看页面元素属性：driver.getAttribute(“value”);10、点击按钮：driver.click();11、操作frame：Driver.switchTo.frame()12、单选下拉列表：Select dropList = new Select(element);Select.getFrestSelectOption().getText();Select.selectByIndex();Select.selectByValue();Select.selectByVisibleText();例子： 单选框：List radioList = driver.findElements();radio. getAttribute(“Value”).equals(“”);radio.isSelectd()radio.click(); 复选框：List checkList = driver.findElements();check.getAttribute(“Value”).equals(“”);check.isSelectd()check.click();13、Alert弹窗：Alert alert = driver.switchTo().alert(); alert.accept();14、执行JavaScript脚本：声明一个JavaScript 执行器对象 JavaScriptExecutor js = (JavaScriptExecutor )driver; js.executeScript(“loginSubmit();”);]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
        <tag>java</tag>
        <tag>web自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmon使用总结]]></title>
    <url>%2F2017%2F07%2F12%2Fnmon%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、安装： 1、下载nmon，wget http://sourceforge.net/projects/nmon/files/nmon_linux_14i.tar.gz 2、拷贝到服务器上，scp nmon_linux_14i.tar.gz root@10.171.112.220:/home 3、解压 4、根据服务器操作系统，执行相关命令二、使用方法： 监控系统性能参数生成监控文件： nmon -f -s 2 -c 300 （每隔2秒采集一次性能参数，总共采集300次，即10分钟） 注意：nmon analyser打开监控文件报错误‘13’:类型不匹配，的解决办法，更改系统日期格式为“yyyy-mm-dd”]]></content>
      <categories>
        <category>性能工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>Nmon</tag>
        <tag>监控工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB基本操作]]></title>
    <url>%2F2017%2F07%2F12%2FmongoDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[工作过程中用到mongodb，在此记录一些使用到的基本命令。 启动：/usr/bin/mongod -f /etc/mongod.conf多条件查询：db.media.find({“$and”:[{“consumername” : “onair”},{“isdel” : “1”}]}).count()]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[st-load安装与使用]]></title>
    <url>%2F2017%2F07%2F11%2Fsrs-bench%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目需要，需对onsite直播服务器做性能测试，尝试了Jmeter，LoadRunner后选择了st-load。 什么是st-load服务器负载测试工具(st-load)：st-load使用nginx-rtmp的协议直接将chunk流解析为messgae。state-threads用来模拟超级并发，并简化异步socket的逻辑为同步socket，http-parser解析http协议部分。这两个库设计都很巧妙，参考大牛开的项目：https://github.com/ossrs/srs-benchstate-threads之前就有写过文章说明，那时候主要是支持高并发的rtmp服务器，也是并发和异步变为同步的协程很方便。http-parser用yum就可以search到，它其实设计得也相当巧妙，相当于只是解析buffer的http内容，并不负责网络部分。而libcurl/poco等都带了网络处理，所以不合适。举例说明，http_parser_parse_url这个函数，解析url，设计得非常有意思，不是返回字符串，而是返回位置索引，譬如主机头在什么位置长度多长等等。 模拟huge并发：2G内存就可以开300k连接。基于states-threads的协程。 支持HLS解析和测试，下载ts片后等待一个切片长度，模拟客户端。支持HLS点播和直播。 支持HTTP负载测试，所有并发重复下载一个http文件。可将80Gbps带宽测试的72Gbps。 支持RTMP流播放测试，一个进程支持5k并发。 支持RTMP流推流测试，一个进程支持500个并发 RTMP协议使用高性能服务器SRS(SimpleRtmpServer)的协议栈。 注意：HTTP/HLS：依赖服务器Content-Length，不支持chunked方式(chunked时会把所有内容当做body一直读)。所有程序都在Linux下运行，模拟客户端运行。其他工具参考srs-librtmp 安装配置安装前需下载安装依赖软件包，使用git下载最新版本的srs-bench源码包 [root@cdvcloud huangyl]# yum install git unzip patch gcc gcc-c++ make [root@cdvcloud huangyl]# git clone https://github.com/simple-rtmp-server/srs-bench.git 编译 [root@cdvcloud srs-bench-master]# ./configure [root@cdvcloud srs-bench-master]# make 查看生成的文件和目录 [root@cdvcloud objs]# ls http-parser-2.1 sb_hls_load sb_rtmp_load sb_rtmp_publish st-1.9 Makefile sb_http_load sb_rtmp_load_fast src 使用方法模拟RTMP播放用户 ./objs/sb_rtmp_load_fast -c 1000 -r rtmp://192.168.0.104/na84qi/dgarfm 模拟HLS直播用户 ./objs/sb_hls_load -c 1 -r http://192.168.0.104/na84qi/dgarfm.m3u8 模拟HSL点播用户 ./objs/st_hls_load -c 1 -o -r http://192.168.0.104/na84qi/dgarfm.m3u8 模拟RTMP推流用户 ./objs/sb_rtmp_publish -i out_time.mp4 -c 1 -r rtmp://192.168.0.103/x1m4eu/16vpuy 模拟RTMP多路推流用户 ./sb_rtmp_publish -i out_time.mp4 -c 1000 -r rtmp://192.168.0.103/live/livestream_{i} example: start a client ./objs/sb_rtmp_load_fast -c 1 -r rtmp://127.0.0.1:1935/live/livestream start 1000 clients ./objs/sb_rtmp_load_fast -c 1000 -r rtmp://127.0.0.1:1935/live/livestream start 10000 clients ./objs/sb_rtmp_load_fast -c 10000 -r rtmp://127.0.0.1:1935/live/livestream start 100000 clients ./objs/sb_rtmp_load_fast -c 100000 -r rtmp://127.0.0.1:1935/live/livestream 参考： http://blog.csdn.net/win_lin/article/details/11835011 http://blog.csdn.net/xiaojun111111/article/details/52102454 http://blog.csdn.net/heiyeshuwu/article/details/52316738 https://github.com/ossrs/srs-bench]]></content>
      <categories>
        <category>性能工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>st-load</tag>
        <tag>直播流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试页]]></title>
    <url>%2F2017%2F07%2F11%2F%E6%B5%8B%E8%AF%95%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[此篇文章测试使用！]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>