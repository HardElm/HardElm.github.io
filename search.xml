<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python学习总结]]></title>
    <url>%2F2017%2F11%2F20%2Fpython%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景略 python简介略 基础有什么环境部署略 中文编码1、python中默认的编码格式是ASCII格式 2、若程序中有中文，需在文件开头加入# -- coding: UTF-8 -- 或者 #coding=utf-8 3、python3.X源码文件默认使用utf-8编码，无需指定utf-8编码 基础语法1、python编程方式 交互式编程：不需要创建脚本文件，通过python解释器的交互模式进行代码编写 脚本式编程：通过脚本参数调用解释器执行脚本，脚本执行完毕后，解释器就不再有效 2、标识符 编程语言的标识符大同小异 数字、字母、下划线 区分大小写 不能以数字开头 _test，以单下划线开头的标识符是不能直接访问的类属性，不能用from XXX import *导入，需要通过类提供的接口进行访问 __test，以双下划线开头的标识符代表类的私有成员、 __test__，以双下划线开头和结尾的标识符代表特殊方法专用的标识，比如__init__()标识类的构造函数 3、保留字符 保留字符可以理解为关键字，保留字符不能被当成常数或者变数，或者是其他任何标识符的名称 ![](https://i.imgur.com/7TXDfmp.png) 4、缩进 python对格式要求非常严格，因为python使用缩进来写模块，不像java需要用大括号{}来控制类、方法和其他的一些逻辑判断 缩进的空白数量可变，但是所有的**代码块语句的缩进空白数量必须保持相同** 5、其他 多行连接符 \ 若语句中包括[]、{}或者()就不需要使用多行连接符进行换行 引号 &apos;&apos;、&quot;&quot;、&apos;&apos;&apos; &apos;&apos;&apos;、&quot;&quot;&quot; &quot;&quot;&quot; 其中三引号可以由多行组成，多行文本的快捷语法经常被用在文件的特定地点，被当做注释来使用 注释 # #用做单行注释 三引号常用作多行注释 空行 空行用来分隔两段不同功能或含义的代码，便于代码维护或重构 一行显示多条语句 ; 如果想在同一行会用多条语句，需要在语句之间使用分号分隔 等待输入 下方语句执行后就会等待用户输入，按回车键后就会退出程序 raw_input(&quot;\n\nPress the enter key to exit.&quot;) Print输出 使用Print进行输出，默认都是换行的，如果想要不换行输出，需要在变量末尾加上逗号 python -h 用来查看各参数帮助信息 变量类型标准数据类型 Number（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 涉及数据类型转换时，可以采用内置函数进行数据类型转码，只需要将数据类型作为函数名，将待转换内容作为参数输入即可 数字数字数据类型用来存储数值，是不可变的数据类型 使用del语句删除对象的引用 python支持四种数字类型 int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） python中使用L来表示长整型，避免使用l与数字1产生混淆 复数由实数部分和虚数部分构成，可表示为a+bj,或者complex(a,b)，复数的实部a和虚部b都是浮点型 字符串字符串由数字、字母和下划线组成的一串字符 一般有两种取值顺序： 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 例： s = &quot;letusmaketest&quot; s1 = s[5]的结果是m s2 = s[9]的结果是t s3 = s[5:9]的结果是make s4 = s[:9]的结果是letusmake s5 = s[5:]的结果是maketest 上面的s3结果包含s[5]的值m，但是不包括s[9]的值t。 加号（+）是字符串连接运算符，比如s + &apos;test&apos; 星号（*）是重复操作，比如s * 2表示s连续输出两次 列表列表是Python中使用最频繁的数据类型 列表可以完成大多数集合类的数据结构实现，支持数字、字符、字符串甚至包含列表（嵌套） 列表中值的切割也可以使用 [头下标:尾下标]的方式，规则和字符串切割取值相同 加号和星号操作与字符串相同 列表可以二次赋值 元组元组和列表类似 元组使用()标识，内部元素用逗号隔开 元组不能二次赋值，相当于只读列表 字典字典是除列表之外Python中最灵活的内置数据结构类型 字典是无序的对象集合，列表是有序的对象集合 字典和列表的区别：字典中的元素是通过键来存取，而列表中的元素是通过偏移来存取 字典用&quot;{}&quot;标识，字典由索引(key)和它对应的值value组成 例： testDic = {} testDic[&apos;test1&apos;] = &apos;This is test1&apos; testDic[2] = &apos;This is test2&apos; testDic2 = {&apos;name&apos;: &apos;huangyl&apos;,&apos;age&apos;:25, &apos;sex&apos;: &apos;man&apos;} print testDic[&apos;test1&apos;] #输出键为&apos;test1&apos;的值 print testDic[2] #输出键为2的值 print testDic2 #输出字典testDic2 print testDic2.keys() #输出字典testDic2的所有键 print testDic2.value() #输出字典testDic2的所有值 基本语句大同小异，基本语句包括： 1、条件语句 2、循环语句 基本分类 1）for循环 2）while循环 3）嵌套循环 控制语句 1）break语句 2）continue语句 3）pass语句 条件语句基本形式： if 判断条件： 执行语句…… else： 执行语句…… 显而易见，如果满足条件，就do A，如果不满足，就do B 以上需要注意的几点： 1、else是可选语句，当需要在条件不成立时执行内容则可以执行相关语句 2、Python不支持switch语句，多个条件判断，只能用elif来实现，即判断条件a后又继续对条件b做了判断 3、需同时判断多个条件时，可判断组合条件。当有多个条件时，判断优先级顺序为：括号&gt;大于/小于&gt;与/或/非 循环语句Python中提供了for循环和while循环以及两种循环的组合形式嵌套循环 Python支持以下循环控制语句： break语句：在语句块执行过程中终止循环，并且跳出整个循环 continue语句：在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环 pass语句：pass是空语句，是为了保持程序结构的完整性 while基本形式： while 判断条件： 执行语句…… ![](https://i.imgur.com/mKQqAUW.gif) 其中： 1、执行语句可以是单个语句也可以是语句块 2、判断条件可以是任何表达式，任何非零、或非空的值均为ture 3、当判断条件为false时，循环结束 未完待续]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker kubernetes]]></title>
    <url>%2F2017%2F11%2F13%2Fdocker-kubernetes%2F</url>
    <content type="text"><![CDATA[背景略 kubernetes]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>自动化部署</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下php项目安装与部署]]></title>
    <url>%2F2017%2F11%2F08%2Flinux%E4%B8%8Bphp%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[背景云收录测试需要，内网原环境由开发和测试共同使用，为避免使用冲突以及确保测试的准确性，需重新部署。在此记录部署过程以及遇到的一些代表性问题。 rpm方式安装yum源配置若yum源已配好，此步略过。 国内开源社区提供了很多yum源地址，常用的163、阿里等等 yum 或者 rpm安装配置yum源 yum cache，yum clean，yum update php+mysql+http等等，nginx可选，通过web访问的提示错误，安装缺少的依赖包（pip等等） yum error rpmts_HdrFromFdno:V3 RSA/SHA1 Signature,key ID c105b9de:NOKEY解决方法：依据linux系统版本，导入相应rpm的签名信息 1、先安装如下工具包： rpm -Uhv http://dag.wieers.com/packages/rpmforge-release/rpmforge-release-0.3.4-1.el4.rf.i386.rpm rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-6 2、一般来说安装完上面的工具包后即可，如果还是不行，查看编辑yum源文件：替换RPM-GPG-KEY-CentOS-5，替换为对应的key文件名：RPM-GPG-KEY-CentOS-6（要全部替换）。 或者以root登录，执行rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release。我的Linux版本是CentOS 6.5，rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 安装软件包1、安装php 2、安装httpd 3、安装mysql 4、安装nginx 5、启动，根据错误信息提示，缺什么装什么 源码方式安装php安装1、下载源码包，此次使用php-5.6.30 2、解压至/usr/local 3、编译安装（./configure，make，make install），若没有gcc环境，要先进行安装 4、启动，根据错误提示信息，缺什么装什么 apache安装1、下载源码包，此次使用httpd 2.4.4。httpd 2.4.4需要较新版本的apr和apr-util，本次使用 apr-1.4.6.tar.bz2与apr-util-1.5.2.tar.bz2版本，注意保证系统时间正确。apr和apr-util的下载路径为：http://archive.apache.org/dist/apr/ 2、解压至/usr/local 3、编译安装（./configure，make，make install） 4、启动，根据错误提示信息，缺什么装什么 4、web访问，根据错误提示信息，缺什么装什么 安装mysql1、yum install mysql 2、启动，根据错误提示信息，缺什么装什么 相关错误以及解决方法PHP提示Call to undefined function mb_substr()解决方法1、打开/etc/php.ini，把extension=php_mbstring.so的注释打开。 2、安装php_mbstring 包 rpm -ivh php-mbstring-4.3.9-3.8.i386.rpm service httpd restart 3、安装完以后需要重启下apache. 解决httpd: Could not reliably determine the server’s fully qualified domain name1、把httpd.conf里面的 #ServerName localhost:80 注释去掉。 2、执行 httpd 3、通过浏览器访问 http://localhost:80 ，如果页面显示 “It works！” ，即表示apache已安装并启动成功。 Python,Django安装MySQLdb各种经典错误(Error No module named MySQLdb)1、缺少MySQLdb模块，可在命令行python中验证。 &gt;&gt;&gt;import MySQLdb 如果报错则没有MySQLdb模块，需安装mysql相关模块。 2、MySQLdb命名错误 参考：http://blog.csdn.net/angel20082008/article/details/26394571[http://blog.csdn.net/angel20082008/article/details/26394571](http://blog.csdn.net/angel20082008/article/details/26394571 &quot;Python,Django安装MySQLdb各种经典错误&quot;) Ppip安装mysql-python报致命错误：my_config.h：没有那个文件或目录yum install mysql-devel 后记： 采用LAMP进行安装部署，网上很多安装教程！！！]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的使用]]></title>
    <url>%2F2017%2F11%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景略 正则表达式简介啥是正则表达式正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式能干啥正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 正则表达式是烦琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本教程，加上应用的时候进行一定的参考，掌握正则表达式不是问题。 许多程序设计语言都支持利用正则表达式进行字符串操作。 使用示例总结功能强大，特别有用！ 附： 参考资料：http://www.runoob.com/regexp/regexp-operator.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xscan漏扫工具的使用]]></title>
    <url>%2F2017%2F10%2F18%2F%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B8%8Exscan%E6%BC%8F%E6%89%AB%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景略 xscan有什么功能采用多线程方式对指定IP地址段(或单机)进行安全漏洞检测，支持插件功能。扫描内容包括：远程服务类型、操作系统类型及版本，各种弱口令漏洞、后门、应用服务漏洞、网络设备漏洞、拒绝服务漏洞等二十几个大类。对于多数已知漏洞，工具都有相应的漏洞描述、解决方案及详细描述链接。 安装与使用安装1、直接google或百度，下载X-Scan，我使用的是X-Scan-v3.3 2、安装X-scan需安装WinPCap驱动程序（什么是WinPCap，以及WinPCap的功能作用，参考百度百科） 使用1、“设置”修改扫描IP或者网段 2、“设置”修改扫描参数，可修改内容包括开放的服务端口，Telnet、SSH、FTP、SQL-Server等协议弱口令以及IIS编解码漏洞等扫描配置内容 3、“设置”修改扫描报告格式，可选html、txt、xml 4、开启任务，可实时监测扫描过程中的普通信息、漏洞信息（开放的服务、端口以及协议类型）、错误信息等内容 总结简单好用，基本满足日常工作使用！ 附： telnet命令：http://www.runoob.com/linux/linux-comm-telnet.html]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>xscan</tag>
        <tag>安全测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab下载与上传压测]]></title>
    <url>%2F2017%2F10%2F18%2Fab%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%B8%8A%E4%BC%A0%E5%8E%8B%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[背景略 简要命令下载ab -n 10000 -c 100 “文件地址” 上传ab -n 10000 -c 100 -T ‘multipart/form-data; boundary=w-QORJuFrcHc6Rwz-RLnKvbtgOIOn0m8mM2DQ’ -p ./abpost.txt “上传接口地址” 上传压测操作方法1、修改abpost.txt内容 1）Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;huangyl.png&quot;，依照例子进行修改 2）Content-Type: MIME，具体格式由上传的文件决定，参考常见的MIME类型 3）对上传的文件进行base64编码，可采用在线转换base64，图片在线转换地址http://tool.css-js.com/base64.html 4）无 2、将abpost.txt放置在执行ab命令的目录下 3、修改总请求数和并发请求数，回车，执行命令 abpost.txt内容--w-QORJuFrcHc6Rwz-RLnKvbtgOIOn0m8mM2DQ Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;huangyl.png&quot; Content-Type: image/png iVBORw0KGgoAAAANSUhEUgAAAkgAAAFmCAYAAACWUGV0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAP+lSURBVHhe7L11lB1Xeq+t+8dd37130GzLFtiWZBJYZmaSmWYyPJnkZjKUDCRjkkEM3S01MzMzMzMzd4tZMtszSb7v/X6/vWufU+f0aant8SSTxL3Ws4rhVFfVfurdtOj/bX5AFK33y0TG7ZK7e7X8w7dukqfvWSVP3HWNPHTbtfLAbdfLfbeulntvXSt337JO7rxlvebmm+SOs3DnLTfPy1233uLktlvPyt233yb33HGb3HfnbXL/nbfLg3fd7Qci8jJUHITPWTSFlKKJxskJYUQU5asiE9mXKVjGTKy0ihvMwUys9MNWSl8rllskNhFLaVHCWtVRQdS3KPLsVhpLeZIsXZXzln2cA732G/kR6X4uxHy5jthG/bN49/3S6hFvDm8fbZXG/5fP3l8bWI6zEnHdcqX7N6TbvXfLxLhoPeD0HXPq5zudZlveYaN3jXuRJ4nWM/eZ+jEXn8Fv5zFoug5duLoO0dAeHX8f8cgo41GkHL/1II//2de8263+zr1tzfGQI6GwSlIP9/IllCWUEWlRdkU3lhNlUU5VBlca5QVZJH1aA0/xdLbVkBjRvcky655BKpVoMYGX6g/x/H/Eel0xKsRgAAAABJRU5ErkJggg== ----w-QORJuFrcHc6Rwz-RLnKvbtgOIOn0m8mM2DQ-- 附：常见的MIME类型(通用型)： 超文本标记语言文本 .html text/html xml文档 .xml text/xml XHTML文档 .xhtml application/xhtml+xml 普通文本 .txt text/plain RTF文本 .rtf application/rtf PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 任意的二进制数据 application/octet-stream]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ab</tag>
        <tag>性能工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试的层级]]></title>
    <url>%2F2017%2F10%2F16%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E5%B1%82%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[背景接《自动化测试的适用范围》 会用工具就是自动化测试工程师吗会使用自动化测试工具的测试人员不能够称之为完全的自动化测试人员，这类测试人员被称为工具小子(Script Kid)。这个阶段还是处于自动化测试的一个比较低级的阶段，因为这些工具都不是测试人员开发的。 对于高手来说，要能写一些独立的测试脚本甚至测试工具。更高的高手则是能脚本和工具和实际工作紧密结合起来，解决工作中遇到的问题。 哪些可以做自动化测试：单元测试单元测试无疑是最适合做自动化的。大多数单元测试是由研发人员完成，测试人员可以不做单元测试，但是可以推动研发人员来编写单元测试用例 单元测试框架1、单元测试常用的框架有很多，比如Java的JUnit，PHP的PHPUnit，Python的unittest等 2、设计自动化单元测试测试用例时一个测试用例通常由三部分组成：setUp，测试逻辑和tearDown，其中setUp用于准备测试数据，tearDown用于清理数据 3、一般单元测试框架都支持装饰器设计模式的注解，比如跳过执行，测试套件的组织，测试用例依赖管理等等 4、单元测试框架可以无缝地在UI测试和接口测试中使用，它们的基本思想都是相通的。 接口测试接口的自动化是目前最适合测试工程师进行自动化的一层。 接口不但变化小，运行速度快，受益高，还有着出现问题后能够很快定位的优点。 UI测试目前，大众眼中关注的比较多的是UI的自动化测试，这是由大家的思维惯性导致的。 传统的测试行业，测试工程师都是从UI下手，来完成所有的测试工作，所以到自动化领域，大家也理所当然的喜欢从UI层来进行自动化。 做UI自动化，最重要的是要能有一个好的自动化测试框架，这里有一些框架的基本设计思路供大家参考： 分布式case增加到一定程度后，如何快速的运行所有的case，这就涉及到分布式的概念。对于Selenium，官方提供了一个Grid，感兴趣的同学可以研究一下。 行为驱动行为驱动就是常说的Cucumber 关键字驱动由『操作对象』、『操作』、『数据』关键字组合成测试用例，框架来把关键字解析为脚本并执行。这种框架最大的优点就是可以提供给不懂代码的测试人员使用，典型的代表是Robot framwork 数据驱动同一段代码的业务逻辑通过更换数据输入来生成多个测试用例，我们只需维护测试数据就可以维护case，这种框架思想在很多测试工具中都有实现 关键字和数据混合驱动较为复杂的测试框架框架，将上述两种框架结合了起来当然，这些思路不仅仅能用在UI层的自动化。对于UI自动化，可以选择只做冒烟测试用例的自动化，这样既可以从UI的角度来重复性的验证主业务主流程没有问题，又可以降低维护成本。]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置http和https代理]]></title>
    <url>%2F2017%2F09%2F19%2Fnginx%E9%85%8D%E7%BD%AEhttp%E5%92%8Chttps%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景近期直播类产品更新，出于安全考虑，播放地址由http转换为https。测试环境部署过程中出现一些小波折，特此记录。 直播间添加特定字段做区分简单采用rewrite进行配置，详细如下： server{ listen 80; server_name 192.168.0.179; root /; location ~ \.m3u8 #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).m3u8$ http://192.168.0.104/$1/$6.m3u8 break; } location ~ \.ts #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).ts$ http://192.168.0.104/$1/$6.ts break; } } 播放地址由http转换为https需注意nginx编译时有无相应的openssl库文件，ldd nginx查看。 简单采用rewrite进行配置，详细如下： server{ listen 443 ssl; server_name 192.168.0.179; ssl on; ssl_certificate ssl/server.crt; ssl_certificate_key ssl/server.key; keepalive_timeout 60; access_log logs/ssl-access.log; error_log logs/ssl-error.log; root /; location ~ \.m3u8 #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).m3u8$ http://192.168.0.104/$1/$6.m3u8 break; } location ~ \.ts #所有jsp的页面均交由tomcat处理 { rewrite ^/(.*)/(.*)/(.*)/(.*)/(.*)/(.*).ts$ http://192.168.0.104/$1/$6.ts break; } } 附：证书生成openssl genrsa -des3 -out server.key 1024 openssl req -new -key server.key -out server.csr cp server.key server.key_bak openssl rsa -in server.key_bak -out server.key openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个常用性能测试工具]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[实践出真知，好不好，只有用用才知道。 几个常用性能测试工具Web BenchWeb Bench是一个简单的web或者web代理服务的基准测试工具。（它）使用fork()模拟多个客户端并且可以发起HTTP/0/9-HTTP/1.1的请求。这个基准测试不是非常符合实际情况，但是可以测试出你的HTTP服务是否可以处理多个客户同时访问而不会把你的机器弄挂掉。这个工具可以获得服务的两个指标：每分钟响应请求数量（pages/min）和每秒钟传输数据量（bytes/sec）。使用-f选项可以运行在主动模式下（不等待服务器响应直接发送下一个请求）。 安装方法参考：（总结）Web性能压力测试工具之WebBench详解 abab即Apache HTTP server benchmarking tool ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。ab命令对发出负载的计算机要求很低，既不会占用很高CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。 ab的用法参考：ab - Apache HTTP server benchmarking tool，（总结）Web性能压力测试工具之ApacheBench（ab）详解 SiegeSiege（英文意思是围攻）是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。 Siege 支持基本的认证，cookies， HTTP 和 HTTPS 协议。 Siege的安装和用法可以参考：Siege Manual，Using Siege to Tune Apache on GNU/Linux，（总结）Web性能压力测试工具之Siege详解，压力测试工具siege的用法 Apache JMeter什么是jmeterApache JMeter是一个专门为运行和服务器装载测试而设计的、100％的纯Java桌面运行程序。原先它是为Web/HTTP测试而设计的，但是它已经扩展以支持各种各样的测试模块。它和用于HTTP和SQL数据库（使用JDBC）的模块一起运送。它可以用来测试静止资料库或者活动资料库中的服务器的运行情况，可以用来模拟对服务器或者网络系统加以重负荷以测试它的抵抗力，或者用来分析不同负荷类型下的所有运行情况。它也提供了一个可替换的界面用来定制数据显示，测试同步及测试的创建和执行。 JMeter的工作原理JMeter可以作为Web服务器与浏览器之间的代理网关，以便捕获浏览器的请求和Web服务器的响应，这样就很容易地生成性能测试脚本，有了性能测试脚本，JMeter就可以通过线程组来模拟真实用户对Web服务器的访问压力，这与LoadRunner的工作原理基本一致。 参考资料JMeter的用户手册：http://jmeter.apache.org/usermanual/index.html 推荐一本书籍：《零成本实现Web性能测试》 JMeter的脚本录制工具：Badboy Web PolygraphWeb Polygraph这个软件也是一个用于测试WEB性能的工具，这个工具是很多公司的标准测试工具，包括微软在分析其软件性能的时候，也是使用这个工具做为基准工具的。很多招聘测试员的广告中都注明需要熟练掌握这个测试工具。 TCPCopyTsungcurl-loaderGrinderGrinder是一个开源的JVM负载测试框架，它通过很多负载注射器来为分布式测试提供了便利。 支持用于执行测试脚本的Jython脚本引擎HTTP测试可通过HTTP代理进行管理。根据项目网站的说法，Grinder的 主要目标用户是“理解他们所测代码的人——Grinder不仅仅是带有一组相关响应时间的‘黑盒’测试。由于测试过程可以进行编码——而不是简单地脚本 化，所以程序员能测试应用中内部的各个层次，而不仅仅是通过用户界面测试响应时间。 LoadRunner（商业软件）LoadRunner 是一种预测系统行为和性能的工业标准级负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner 能够对整个企业架构进行测试。通过使用LoadRunner ， 企业能最大限度地缩短测试时间， 优化性能和加速应用系统的发布周期。企业的网络应用环境都必须支持大量用户，网络体系架构中含各类应用环境且由不同供应商提供软件和硬件产品。难以预知的用户负载和愈来愈复杂的应用环境使公司时时担心会发生用户响应速度过慢， 系统崩溃等问题。这些都不可避免地导致公司收益的损失。Mercury Interactive 的 LoadRunner 能让企业保护自己的收入来源， 无需购置额外硬件而最大限度地利用现有的IT 资源， 并确保终端用户在应用系统的各个环节中对其测试应用的质量， 可靠性和可扩展性都有良好的评价。LoadRunner 是一种适用于各种体系架构的自动负载测试工具， 它能预测系统行为并优化系统性能。LoadRunner 的测试对象是整个企业的系统， 它通过模拟实际用户的操作行为和实行实时性能监测， 来帮助您更快的查找和发现问题。此外，LoadRunner 能支持广范的协议和技术， 为您的特殊环境提供特殊的解决方案。 kylinpet（国产商业工具）kylinPET（performance emulation tool，麒麟宠物）是一款功能强大的性能测试工具；界面友好、操作方便，资源占用率低；自带TCP/IP协议栈，支持虚拟大量IP；支持IPv4、IPv6的多种业务测试；支持WEB/WebService业务与Flex（HTTP）、IMS业务（SIP）、IPTV业务（RTSP/IGMP/MLD）、XMPP、Socket业务、数据库、JMS、FTP/SFTP、WEB视频（包括FLV/MP4/HTTP Live Streaming/HTTP Smooth Streaming/HTTP Dynamic Streaming）、WebSocket、JAVA；支持多种协议组合。 总结一些性能测试的做法1、为了减少网络延迟和带宽限制对性能测试的影响，最好在内网进行测试。 2、性能测试一般在优化前和优化后，测试两轮，这样能够比较出优化前后的效果。 3、性能测试最好跑的时间长一些，观察程序是否存在内存泄漏、资源未释放等问题。 4、有的公司为了避免影响线上环境，只在测试环境做性能测试。性能测试一般在线下线上都要做，线上做性能测试可以了解生产环境的性能情况。 参考： http://www.cnblogs.com/EthanCai/archive/2014/05/11/3721656.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>测试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11款常用的web应用框架]]></title>
    <url>%2F2017%2F08%2F10%2F%E5%87%A0%E6%AC%BE%E5%B8%B8%E7%94%A8%E7%9A%84web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[几款常用的web应用框架 Rails 代码托管地址：https://github.com/rails/rails Express 代码托管地址：https://github.com/rails/rails Django 代码托管地址：https://github.com/django/django Meteor 代码托管地址：https://github.com/meteor/meteor CakePHP 代码托管地址：https://github.com/cakephp/cakephp Symfony 代码托管地址：https://github.com/symfony/symfony Sinatra 代码托管地址：https://github.com/sinatra/sinatra Flask 代码托管地址：https://github.com/mitsuhiko/flask Laravel 代码托管地址：https://github.com/laravel/laravel Sails 代码托管地址：https://github.com/balderdashy/sails Revel 代码托管地址：https://github.com/revel/revel 参考文档：https://yusi123.com/3654.html]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>web应用框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下expect脚本语言的简单使用]]></title>
    <url>%2F2017%2F07%2F24%2FExpect%E4%BA%A4%E4%BA%92%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景最近在做直播服务器性能测试，因单台推流服务器性能限制，需多台机器同时推流，而且要监控直播平台各个底层服务器的性能，手动推流并开启监控繁琐而且易出错，故有如下内容。 什么是Expect介绍Expect是一个用来实现自动交互功能的软件套件。使用它，系统管理员可以创建脚本来对命令或程序进行输入，而这些命令和程序是期望从终端（terminal）得到输入，一般来说这些输入都需要手工输入进行的。Expect则可以根据程序的提示模拟标准输入提供给程序需要的输入来实现交互程序执行。甚至可以实现简单的BBS聊天机器人。 Expect是不断发展的，随着时间的流逝，其功能越来越强大，已经成为系统管理员的的一个强大助手。Expect需要Tcl编程语言的支持，要在系统上运行Expect必须首先安装Tcl。 Expect的四个关键命令：spawn：启动新的进程 expect：从进程接收字符串 send：用于向进程发送字符串 interact：允许用户交互 安装直接使用yum安装相关依赖库以及expect yum install tcl yum install expect 使用pushtestall.sh远程登录启动nmon监控和ffmpeg推流脚本 #!/usr/bin/expect -f set password CDVcloud123 set listnmon /home/huangyl/nmon set listffmpeg /home/huangyl set script loop.sh set timeout -1 #外网登录推流1 spawn ssh root@101.201.237.216 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } #登录入口1,并开启nmon监控 spawn ssh root@172.18.1.14 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录入口2，并开启nmon监控 spawn ssh root@172.18.29.128 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录出口1，并开启nmon监控 spawn ssh root@172.18.29.124 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录出口2，并开启nmon监控 spawn ssh root@172.18.1.15 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口1，并开启nmon监控 spawn ssh root@172.18.1.17 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口2，并开启nmon监控 spawn ssh root@172.18.29.125 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录直播1，并开启nmon监控 spawn ssh root@172.18.1.16 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录直播2，并开启nmon监控 spawn ssh root@172.18.29.127 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录推流1，执行推流命令 spawn ssh root@172.18.1.6 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #登录推流2，执行推流命令 spawn ssh root@172.18.1.9 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #登录推流2，执行推流命令 spawn ssh root@172.18.1.18 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listffmpeg\r&quot; expect &quot;*#&quot; send &quot;./$script\r&quot; #控制权移交 interact killffmpeg.sh#!/usr/bin/expect -f set password CDVcloud123 #set listnmon /home/huangyl/nmon set listffmpeg /home/huangyl set timeout -1 #外网登录推流1，并杀死ffmpeg spawn ssh root@101.201.237.216 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #内网登录推流2，并杀死ffmpeg spawn ssh root@172.18.1.9 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #内网登录推流3，并杀死ffmpeg spawn ssh root@172.18.1.18 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;ps -ef|grep ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; expect &quot;*#&quot; send &quot;killall ffmpeg\r&quot; #控制权移交 interact playtest.shsrs_bench压测 #!/usr/bin/expect -f set password CDVcloud123 set listnmon /home/huangyl/nmon set listbench /home/huangyl/srs-bench-master/objs set usernum 1 set roadname https://zbfee.cdvcloud.com/551016/551016/7t3dmx/g96gwq/06ijj2.m3u8 #set script loop.sh set timeout 30 #登录出口1，打开nmon监控 spawn ssh root@172.18.29.124 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录出口2，打开nmon监控 spawn ssh root@172.18.1.15 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; #登录接口1，打开nmon监控 spawn ssh root@172.18.1.17 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录接口2，打开nmon监控 spawn ssh root@172.18.29.125 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listnmon\r&quot; expect &quot;*#&quot; send &quot;./nmon -f -s 5 -c 800\r&quot; ##登录srs_bench，开始模拟直播观看 spawn ssh root@172.18.1.6 expect { &quot;*yes/no&quot; { send &quot;yes\r&quot;; exp_continue } &quot;*password:&quot; { send &quot;$password\r&quot; } } expect &quot;*#&quot; send &quot;ifconfig\r&quot; expect &quot;eth0*&quot; send &quot;cd $listbench\r&quot; expect &quot;*#&quot; send &quot;./sb_hls_load -c $usernum -r $roadname\r&quot; #控制权移交 interact 以上，深深的感受到自动化脚本语言的强大~]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Expect</tag>
        <tag>性能测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理修改DNS]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%89%B9%E5%A4%84%E7%90%86%E4%BF%AE%E6%94%B9DNS%2F</url>
    <content type="text"><![CDATA[工作中经常要登录线上环境和内网测试环境，手动修改DNS甚是麻烦，特写下如下命令，顺带简单学习下批处理命令： @echo off cls echo 请选择DNS设置为内网（y）or外网（n）： set /p name= if &quot;%name%&quot;==&quot;y&quot; goto Ys if &quot;%name%&quot;==&quot;n&quot; goto No :Ys echo.正在修改dns··· netsh interface ip set dns &quot;本地连接&quot; static 192.168.0.88 primary echo 已设置为192.168.0.88 &gt;nul&amp;&amp;exit :No echo.正在修改dns··· netsh interface ip set dns name=&quot;本地连接&quot; source=dhcp echo 已设置为自动获取DNS &gt;nul&amp;&amp;exit]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于ffmpeg进行转码工具的编写（未完成）]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%9F%BA%E4%BA%8Effmpeg%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考了一些资料，学习过程中尝试写一个转码工具，由于一些个人能力和其他的一些原因暂时搁置，特此记录一些代码，留作参考。 一、GUI： package cn.com.huangyl.tool; import java.awt.BorderLayout; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.Calendar; import java.util.List; import javax.swing.DefaultComboBoxModel; import javax.swing.JButton; import javax.swing.JComboBox; import javax.swing.JFileChooser; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTabbedPane; import javax.swing.JTextArea; import javax.swing.JTextField; public class FFmpegGUI { private JFrame frame = new JFrame(&quot;FFmpegGUI&quot;); private JTabbedPane tabbedPane = new JTabbedPane(); private JPanel panel1 = new JPanel(new BorderLayout()); private JPanel panelx = new JPanel(new BorderLayout()); private JPanel panely = new JPanel(new BorderLayout()); private JPanel panel2 = new JPanel(new BorderLayout()); private JPanel panel3 = new JPanel(new GridLayout(2, 1)); private JPanel panel4 = new JPanel(new BorderLayout()); private JPanel panel5 = new JPanel(new BorderLayout()); private JPanel panel6 = new JPanel(new BorderLayout()); private JPanel panel7 = new JPanel(new BorderLayout()); private JPanel panel8 = new JPanel(new BorderLayout()); private JPanel panel9 = new JPanel(new BorderLayout()); private JPanel panel10 = new JPanel(new BorderLayout()); private JPanel panel11 = new JPanel(new BorderLayout()); private JPanel panel12 = new JPanel(new GridLayout(6,1)); private JPanel panel13 = new JPanel(new GridLayout(6,1)); private JPanel panel14 = new JPanel(new BorderLayout()); private JPanel panel15 = new JPanel(new BorderLayout()); private JPanel panel16 = new JPanel(new BorderLayout()); private JPanel panel17 = new JPanel(new BorderLayout()); private JPanel panel18 = new JPanel(new GridLayout(1,2)); private JPanel panel19 = new JPanel(new BorderLayout()); private JPanel panel20 = new JPanel(new BorderLayout()); private JButton Select = new JButton(&quot;选择&quot;); private JButton StartTranscode = new JButton(&quot;开始&quot;); private JButton Reset = new JButton(&quot;重置&quot;); //private JTextField display = new JTextField(&quot;请点击查询按钮&quot;); private JTextField FilePath = new JTextField(&quot;请选择文件路径&quot;); private JTextField VideoBitrate = new JTextField(); private JTextField resolution = new JTextField(); private JTextField AudioBitrate = new JTextField(); private JTextField AudioSampleRate = new JTextField(); private JTextField CreateFileName = new JTextField(); private JTextField CreateFileFormat = new JTextField(); private JLabel label1 = new JLabel(&quot;请选择文件&quot;); private JLabel label2 = new JLabel(&quot;模板转码&quot;); private JLabel label3 = new JLabel(&quot;请选择模板：&quot;); private JLabel label4 = new JLabel(&quot;自由转码&quot;); private JLabel label5 = new JLabel(&quot;视频码率：&quot;); private JLabel label6 = new JLabel(&quot;分辨率：&quot;); private JLabel label7 = new JLabel(&quot;音频码率：&quot;); private JLabel label8 = new JLabel(&quot;音频采样率：&quot;); private JLabel label9 = new JLabel(&quot;请选择转码方式：&quot;); private JLabel label10 = new JLabel(&quot;留做进度条：&quot;); private JLabel label11 = new JLabel(&quot;生成文件名称：&quot;); private JLabel label12 = new JLabel(&quot;生成文件格式：&quot;); private JComboBox Template = new JComboBox(); private JComboBox TranscodeWay = new JComboBox(); private JTextArea Log = new JTextArea(&quot;&quot;); private JScrollPane scrollPane1 = new JScrollPane(); private JFileChooser stf = new JFileChooser(new File(&quot;d://&quot;)); FFmpegGUI(){ frame.setLayout(null); frame.setBounds(400, 200, 700, 420); frame.setVisible(true); frame.setDefaultCloseOperation(3); tabbedPane.addTab(&quot;ffmpeg&quot;, this.panel1); tabbedPane.addTab(&quot;ffplay&quot;, this.panelx); tabbedPane.addTab(&quot;ffprobe&quot;, this.panely); tabbedPane.setBounds(10, 10, 660, 360); frame.add(this.tabbedPane); panel1.add(&quot;West&quot;,panel2); panel1.add(&quot;Center&quot;,panel19); panel19.add(&quot;Center&quot;,Log); panel19.add(&quot;South&quot;,label10); panel2.add(&quot;North&quot;,panel3); panel2.add(&quot;Center&quot;,panel8); panel3.add(panel4); panel3.add(panel5); panel4.add(&quot;North&quot;,label1); panel4.add(&quot;South&quot;,panel6); panel5.add(&quot;North&quot;,label2); panel5.add(&quot;South&quot;,panel7); panel6.add(&quot;Center&quot;,FilePath); panel6.add(&quot;East&quot;,Select); Template.setModel(new DefaultComboBoxModel(new String[] { &quot;1080p_1920x1080_2000&quot;, &quot;SHD_1280x720_1200&quot;, &quot;HD_960x540_800&quot;, &quot;SD_640x360_500&quot;, &quot;LD_360x240_300&quot;,&quot;...&quot; })); Template.setEditable(false); panel7.add(&quot;Center&quot;,Template); panel7.add(&quot;West&quot;,label3); panel8.add(&quot;North&quot;,label4); panel8.add(&quot;Center&quot;,panel9); panel9.add(&quot;North&quot;,panel10); panel9.add(&quot;Center&quot;,panel11); panel10.add(&quot;West&quot;,panel12); panel10.add(&quot;Center&quot;,panel13); panel12.add(label5); panel12.add(label6); panel12.add(label7); panel12.add(label8); panel12.add(label11); panel12.add(label12); panel13.add(VideoBitrate); panel13.add(resolution); panel13.add(AudioBitrate); panel13.add(AudioSampleRate); panel13.add(CreateFileName); panel13.add(CreateFileFormat); panel11.add(&quot;North&quot;,panel14); panel11.add(&quot;Center&quot;,panel15); TranscodeWay.setModel(new DefaultComboBoxModel(new String[] { &quot;模板转码&quot;, &quot;自由转码&quot; })); TranscodeWay.setEditable(false); panel14.add(&quot;West&quot;,label9); panel14.add(&quot;Center&quot;,TranscodeWay); panel15.add(&quot;Center&quot;,panel16); panel15.add(&quot;South&quot;,panel17); panel17.add(&quot;East&quot;,panel18); panel18.add(Reset); panel18.add(StartTranscode); //文件选择 this.Select.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent event){ FFmpegGUI.this.stf.setFileSelectionMode(0); int state = FFmpegGUI.this.stf.showOpenDialog(null); if(state == 1){ return; } File f = FFmpegGUI.this.stf.getSelectedFile(); FFmpegGUI.this.FilePath.setText(f.getAbsolutePath()); } }); this.StartTranscode.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { String transcodeway = FFmpegGUI.this.TranscodeWay.getSelectedItem().toString(); if (&quot;模板转码&quot;.equals(transcodeway)) { String sourcefile = FFmpegGUI.this.FilePath.getText(); String Template = FFmpegGUI.this.TranscodeWay.getSelectedItem().toString(); FFmpegGUI.this.Log.setText(sourcefile); Transcode t = new Transcode(); } if (&quot;自由转码&quot;.equals(transcodeway)){ String sourcefile = FFmpegGUI.this.FilePath.getText(); String VideoBitrate = FFmpegGUI.this.VideoBitrate.getText(); String resolution = FFmpegGUI.this.resolution.getText(); String AudioBitrate = FFmpegGUI.this.AudioBitrate.getText(); String AudioSampleRate = FFmpegGUI.this.AudioSampleRate.getText(); String CreateFileName = FFmpegGUI.this.CreateFileName.getText(); String CreateFileFormat = FFmpegGUI.this.CreateFileFormat.getText(); Transcode t = new Transcode(); try { t.processTranscodefree(sourcefile,VideoBitrate,resolution,AudioBitrate,AudioSampleRate,CreateFileName,CreateFileFormat); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }); } public static void main(String args[]){ new FFmpegGUI(); } } 二、Transcode package cn.com.huangyl.tool; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class Transcode { /* private static int checkContentType(){ String type = sourcefile.substring(PATH.lastIndexOf(&quot;.&quot;) + 1, sourcefile.length()) .toLowerCase(); //ffmpeg能解析的格式:(asx，asf，mpg，wmv，3gp，mp4，mov，avi，flv等) if (type.equals(&quot;avi&quot;)) { return 0; } else if (type.equals(&quot;mpg&quot;)) { return 0; } else if (type.equals(&quot;wmv&quot;)) { return 0; } else if (type.equals(&quot;3gp&quot;)) { return 0; } else if (type.equals(&quot;mov&quot;)) { return 0; } else if (type.equals(&quot;mp4&quot;)) { return 0; } else if (type.equals(&quot;asf&quot;)) { return 0; } else if (type.equals(&quot;asx&quot;)) { return 0; } else if (type.equals(&quot;flv&quot;)) { return 0; } //对ffmpeg无法解析的文件格式(wmv9，rm，rmvb等),可以先用别的工具（mencoder）转换为avi(ffmpeg能解析的)格式. else if (type.equals(&quot;wmv9&quot;)) { return 1; } else if (type.equals(&quot;rm&quot;)) { return 1; } else if (type.equals(&quot;rmvb&quot;)) { return 1; } return 9; } // 对ffmpeg无法解析的文件格式(wmv9，rm，rmvb等), 可以先用别的工具（mencoder）转换为avi(ffmpeg能解析的)格式. private static String processAVI(int type) { List&lt;String&gt; commend = new ArrayList&lt;String&gt;(); commend.add(&quot;c:\\ffmpeg\\mencoder&quot;); commend.add(sourcefile); commend.add(&quot;-oac&quot;); commend.add(&quot;lavc&quot;); commend.add(&quot;-lavcopts&quot;); commend.add(&quot;acodec=mp3:abitrate=64&quot;); commend.add(&quot;-ovc&quot;); commend.add(&quot;xvid&quot;); commend.add(&quot;-xvidencopts&quot;); commend.add(&quot;bitrate=600&quot;); commend.add(&quot;-of&quot;); commend.add(&quot;avi&quot;); commend.add(&quot;-o&quot;); commend.add(&quot;c:\\ffmpeg\\output\\a.avi&quot;); try { ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); builder.start(); return &quot;c:\\ffmpeg\\output\\a.avi&quot;; } catch (Exception e) { e.printStackTrace(); return null; } } public void processTranscodetemp(String Template,String sourcefile) throws Exception { String type = sourcefile.substring(sourcefile.lastIndexOf(&quot;.&quot;) + 1, sourcefile.length()) .toLowerCase(); String F1080p_1920x1080_2000 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 2000k -r 25 -s 1920x1080 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;1080P_2M.&quot;+type; String SHD_1280x720_1200 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 1200k -r 25 -s 1280x720 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;720P_1200.&quot;+type; String HD_960x540_800 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 800k -r 25 -s 960x540 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;540P_800.&quot;+type; String SD_640x360_500 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 500k -r 25 -s 640x360 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;360P_500.&quot;+type; String LD_360x240_300 = &quot;ffmpeg -i &quot;+sourcefile+&quot;-vcodec h264 -b:v 300k -r 25 -s 360x240 -pix_fmt yuv420p -g 33 -acodec aac -b:a 128k -ar 44100 -ac 2 -strict -2 -f &quot;+ type +&quot; -y &quot;+ &quot;240P_500.&quot;+type; if (!checkfile(sourcefile)) { System.out.println(sourcefile + &quot; is not file&quot;); } try{ Runtime rt = Runtime.getRuntime(); Process proc; proc = rt.exec(F1080p_1920x1080_2000); // 取得命令结果的输出流 InputStream fis = proc.getInputStream(); // 用一个读输出流类去读 InputStreamReader isr = new InputStreamReader(fis); // 用缓冲器读行 BufferedReader br = new BufferedReader(isr); String line = null; // 直到读完为止 while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } */ public boolean processTranscodefree(String sourcefile,String VideoBitrate,String resolution,String AudioBitrate,String AudioSampleRate,String CreateFileName,String CreateFileFormat) throws Exception{ File diretory = new File(&quot;&quot;); String currPath = diretory.getAbsolutePath(); String outputPath = currPath + &quot;\\output\\&quot;; String ffmpegPath = currPath + &quot;\\FFmpeg\\bin\\&quot;; if (!checkfile(sourcefile)) { System.out.println(sourcefile + &quot; is not file&quot;); } // 文件命名 //Calendar c = Calendar.getInstance(); List&lt;String&gt; commend = new ArrayList&lt;String&gt;(); commend.add(ffmpegPath+&quot;ffmpeg.exe&quot;); //commend.add(&quot;F:\\java\\TranscodeGUI\\ffmpeg.exe&quot;); commend.add(&quot;-i&quot;); commend.add(sourcefile); commend.add(&quot;-ab&quot;); commend.add(&quot;-vcodec&quot;); commend.add(&quot;h264&quot;); //commend.add(&quot;&quot;); commend.add(&quot;-b:v&quot;); commend.add(VideoBitrate); commend.add(&quot;-r&quot;); commend.add(&quot;25&quot;); commend.add(&quot;-s&quot;); commend.add(&quot;resolution&quot;); commend.add(&quot;-pix_fmt&quot;); commend.add(&quot;yuv420p&quot;); commend.add(&quot;-g&quot;); commend.add(&quot;33&quot;); commend.add(&quot;-acodec&quot;); commend.add(&quot;aac&quot;); commend.add(&quot;-b:a&quot;); commend.add(AudioBitrate); commend.add(&quot;-ac&quot;); commend.add(&quot;2&quot;); commend.add(&quot;-strict&quot;); commend.add(&quot;-2&quot;); commend.add(&quot;-f&quot;); commend.add(CreateFileFormat); commend.add(&quot;-y&quot;); commend.add(outputPath+CreateFileName+&quot;.&quot;+CreateFileFormat); try { ProcessBuilder builder = new ProcessBuilder(); builder.command(commend); Process proc = builder.start(); InputStream stderr = proc.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line = null; while ( (line = br.readLine()) != null) System.out.println(line); int exitVal = proc.waitFor(); System.out.println(&quot;Process exitValue: &quot; + exitVal); } catch (Throwable t) { t.printStackTrace(); return false; } return true; } /* try { Runtime rt = Runtime.getRuntime(); ProcessBuilder builder = new ProcessBuilder(commend); builder.command(commend); builder.start(); System.out.println(&quot;开始转码，请等待······&quot;); } catch (Exception e) { e.printStackTrace(); System.out.println(&quot;转码异常，请查看日志！&quot;); } */ //检查文件是否存在 private static boolean checkfile(String path) { File file = new File(path); if (!file.isFile()) { return false; } return true; } }]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试的适用范围]]></title>
    <url>%2F2017%2F07%2F12%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[什么情况适用自动化测试 什么情况不适用自动化测试 一、不适合自动化测试的情况 • 定制型项目（一次性的）。为客户定制的项目，维护期由客户方承担的，甚至采用的开发语言、运行环境也是客户特别要求的，即公司在这方面的测试积累就少，这样的项目不适合作自动化测试。 • 项目周期很短的项目。项目周期很短，测试周期很短，就不值得花精力去投资自动化测试，好不容易建立起的测试脚本，不能得到重复的利用是不现实的。 • 业务规则复杂的对象。业务规则复杂的对象，有很多的逻辑关系、运算关系，工具就很难测试。 • 美观、声音、易用性测试。人的感观方面的：界面的美观、声音的体验、易用性的测试，也只有人来测试。 • 测试很少运行。测试很少运行，对自动化测试就是一种浪费。自动化测试就是让它不厌其烦的、反反复复的运行才有效率。 • 软件不稳定。软件不稳定，则会由于这些不稳定因素导致自动化测试失败。只有当软件达到相对的稳定，没有界面性严重错误和中断错误才能开始自动化测试。 • 涉及物理交互。工具很难完成与物理设备的交互，比如刷卡的测试等。 二、适合自动化测试的情况 自动化测试之所以能在很多大公司实施起来，就是有它适合自动化测试的特点和高的投资回报率。 • 产品型项目。产品型的项目，每个项目只改进少量的功能，但每个项目必须反反复复的测试那些没有改动过的功能。这部分测试完全可以让自动化测试来承担， 同时可以把新加入的功能的测试也慢慢地加入到自动化测试当中。 • 增量式开发、持续集成项目。由于这种开发模式是频繁的发布新版本进行测试，也就需要频繁的自动化测试，以便把人从中解脱出来测试新的功能。 • 能够自动编译、自动发布的系统。要能够完全实现自动化测试，必须具有能够自动化编译，自动化发布系统进行测试的功能。 当然，不能达到这个要求也可以在手工干预的情况下进行自动化测试。 • 回归测试。回归测试是自动化测试的强项，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。 • 多次重复、机械性动作，将烦琐的任务转化为自动化测试。自动化测试最适用于多次重复、机械性动作，这样的测试对它来说从不会失败。比如要向系统输入大量的相似数据来测试压力和报表。 • 需要频繁运行测试。在一个项目中需要频繁的运行测试，测试周期按天算，就能最大限度的利用测试脚本]]></content>
      <categories>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ学习总结]]></title>
    <url>%2F2017%2F07%2F12%2Frabbitmq%2F</url>
    <content type="text"><![CDATA[什么是RabbitMQMessage Queue（MQ），消息队列是一种应用程序对应用程序的通信方法。应用程序通过读写MQ的消息（针对应用程序的数据）来通信，而无需建立专用连接来链接它们。MQ是消费者-生产模型的一个典型代表，一段不断写入消息，而另一段可以读取或者订阅队列中的消息。MQ是遵循AMQP协议的具体实现和产品。 适用场景RabbitMQ，或者说AMQP解决了什么问题，或者说它的应用场景是什么？ 对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如： 1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？ 2）如何降低发送者和接收者的耦合度？ 3）如何让Priority高的接收者先接到数据？ 4）如何做到load balance？有效均衡接收者的负载？ 5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。 6）如何做到可扩展，甚至将这个通信模块发到cluster上？ 7）如何保证接收者接收到了完整，正确的数据？ AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 安装部署1、安装erlang 1）下载erlang源码，解压，进入$erlang目录，安装依赖包： yum install tk yum install tcl yum install unixODBC 2）编译erlang ./configure –prefix=/usr/local/erlang ./make ./make install 3）将erlang的bin目录添加至PATH 2、安装RabitMQ 1）下载RabbitMQ，解压至$RMQ 2）启动RabbitMQ ./bin/rabbitmq-server start 实际使用1、创建未完 相关博客链接：http://blog.csdn.net/column/details/rabbitmq.html]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium初学总结]]></title>
    <url>%2F2017%2F07%2F12%2FSelenium%E5%88%9D%E5%AD%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[工作中研究过一段时间自动化，因为一些原因暂时搁置了，以后会再捡起来，特记录一些selenium基本知识，供以后复习使用。 selenium集成java的一些常用方法： 1、页面元素定位方法：ID: driver.findElement(By.id(“ID值”));Name: driver.findElement(By.name(“name值”));链接的全部文字 : driver.findElement(By.linkText(“链接的全部文字内容”));部分链接文字: driver.findElement(By.partialLinkText(“链接的部分文字内容”));Xpath : driver.findElement(By.xpath(“Xpath定位表达式”));CSS: driver.findElement(By.cssSelector(“CSS定位表达式”));Class: driver.findElement(By.className(“页面元素的Class属性值”));标签名称:driver.findElement(By.tagName (“页面元素的HTML标签名称”)); 2、打开浏览器：打开firefox ： WebDriver driver= new FirefoxDriver();打开ie ：WebDriver driver =new InternetExplorerDriver();打开chrome： WebDriver driver = new ChromeDriver();打开指定路径浏览器 ： System.setProperty(“webdriver.firefox.bin”,”D:\ProgramFiles\MozillaFirefox\firefox.exe”); 3、关闭浏览器：driver.close();driver.quit(); 4、返回当前页面Title URLdriver.getTitle();driver.getCurrentUrl(); 5、返回上一个访问的网页driver.navigate().to(url1);driver.navigate().to(url2);driver.navigate().back();6、刷新当前网页：driver.navigate().refresh();7、输入框中输入指定内容:driver.sendKeys();8、输入框中清除文字内容：driver.clear();9、查看页面元素属性：driver.getAttribute(“value”);10、点击按钮：driver.click();11、操作frame：Driver.switchTo.frame()12、单选下拉列表：Select dropList = new Select(element);Select.getFrestSelectOption().getText();Select.selectByIndex();Select.selectByValue();Select.selectByVisibleText();例子： 单选框：List radioList = driver.findElements();radio. getAttribute(“Value”).equals(“”);radio.isSelectd()radio.click(); 复选框：List checkList = driver.findElements();check.getAttribute(“Value”).equals(“”);check.isSelectd()check.click();13、Alert弹窗：Alert alert = driver.switchTo().alert(); alert.accept();14、执行JavaScript脚本：声明一个JavaScript 执行器对象 JavaScriptExecutor js = (JavaScriptExecutor )driver; js.executeScript(“loginSubmit();”);]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>Selenium</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmon使用总结]]></title>
    <url>%2F2017%2F07%2F12%2Fnmon%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、安装： 1、下载nmon，wget http://sourceforge.net/projects/nmon/files/nmon_linux_14i.tar.gz 2、拷贝到服务器上，scp nmon_linux_14i.tar.gz root@10.171.112.220:/home 3、解压 4、根据服务器操作系统，执行相关命令二、使用方法： 监控系统性能参数生成监控文件： nmon -f -s 2 -c 300 （每隔2秒采集一次性能参数，总共采集300次，即10分钟） 注意：nmon analyser打开监控文件报错误‘13’:类型不匹配，的解决办法，更改系统日期格式为“yyyy-mm-dd”]]></content>
      <categories>
        <category>性能工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>Nmon</tag>
        <tag>监控工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB基本操作]]></title>
    <url>%2F2017%2F07%2F12%2FmongoDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[工作过程中用到mongodb，在此记录一些使用到的基本命令。 启动：/usr/bin/mongod -f /etc/mongod.conf多条件查询：db.media.find({“$and”:[{“consumername” : “onair”},{“isdel” : “1”}]}).count()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[st-load安装与使用]]></title>
    <url>%2F2017%2F07%2F11%2Fsrs-bench%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目需要，需对onsite直播服务器做性能测试，尝试了Jmeter，LoadRunner后选择了st-load。 什么是st-load服务器负载测试工具(st-load)：st-load使用nginx-rtmp的协议直接将chunk流解析为messgae。state-threads用来模拟超级并发，并简化异步socket的逻辑为同步socket，http-parser解析http协议部分。这两个库设计都很巧妙，参考大牛开的项目：https://github.com/ossrs/srs-benchstate-threads之前就有写过文章说明，那时候主要是支持高并发的rtmp服务器，也是并发和异步变为同步的协程很方便。http-parser用yum就可以search到，它其实设计得也相当巧妙，相当于只是解析buffer的http内容，并不负责网络部分。而libcurl/poco等都带了网络处理，所以不合适。举例说明，http_parser_parse_url这个函数，解析url，设计得非常有意思，不是返回字符串，而是返回位置索引，譬如主机头在什么位置长度多长等等。 模拟huge并发：2G内存就可以开300k连接。基于states-threads的协程。 支持HLS解析和测试，下载ts片后等待一个切片长度，模拟客户端。支持HLS点播和直播。 支持HTTP负载测试，所有并发重复下载一个http文件。可将80Gbps带宽测试的72Gbps。 支持RTMP流播放测试，一个进程支持5k并发。 支持RTMP流推流测试，一个进程支持500个并发 RTMP协议使用高性能服务器SRS(SimpleRtmpServer)的协议栈。 注意：HTTP/HLS：依赖服务器Content-Length，不支持chunked方式(chunked时会把所有内容当做body一直读)。所有程序都在Linux下运行，模拟客户端运行。其他工具参考srs-librtmp 安装配置安装前需下载安装依赖软件包，使用git下载最新版本的srs-bench源码包 [root@cdvcloud huangyl]# yum install git unzip patch gcc gcc-c++ make [root@cdvcloud huangyl]# git clone https://github.com/simple-rtmp-server/srs-bench.git 编译 [root@cdvcloud srs-bench-master]# ./configure [root@cdvcloud srs-bench-master]# make 查看生成的文件和目录 [root@cdvcloud objs]# ls http-parser-2.1 sb_hls_load sb_rtmp_load sb_rtmp_publish st-1.9 Makefile sb_http_load sb_rtmp_load_fast src 使用方法模拟RTMP播放用户 ./objs/sb_rtmp_load_fast -c 1000 -r rtmp://192.168.0.104/na84qi/dgarfm 模拟HLS直播用户 ./objs/sb_hls_load -c 1 -r http://192.168.0.104/na84qi/dgarfm.m3u8 模拟HSL点播用户 ./objs/st_hls_load -c 1 -o -r http://192.168.0.104/na84qi/dgarfm.m3u8 模拟RTMP推流用户 ./objs/sb_rtmp_publish -i out_time.mp4 -c 1 -r rtmp://192.168.0.103/x1m4eu/16vpuy 模拟RTMP多路推流用户 ./sb_rtmp_publish -i out_time.mp4 -c 1000 -r rtmp://192.168.0.103/live/livestream_{i} example: start a client ./objs/sb_rtmp_load_fast -c 1 -r rtmp://127.0.0.1:1935/live/livestream start 1000 clients ./objs/sb_rtmp_load_fast -c 1000 -r rtmp://127.0.0.1:1935/live/livestream start 10000 clients ./objs/sb_rtmp_load_fast -c 10000 -r rtmp://127.0.0.1:1935/live/livestream start 100000 clients ./objs/sb_rtmp_load_fast -c 100000 -r rtmp://127.0.0.1:1935/live/livestream 参考： http://blog.csdn.net/win_lin/article/details/11835011 http://blog.csdn.net/xiaojun111111/article/details/52102454 http://blog.csdn.net/heiyeshuwu/article/details/52316738 https://github.com/ossrs/srs-bench]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>st-load</tag>
        <tag>直播流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试页]]></title>
    <url>%2F2017%2F07%2F11%2F%E6%B5%8B%E8%AF%95%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[此篇文章测试使用！]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>